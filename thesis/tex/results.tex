\chapter{Results and Applications}
\label{chapter:results}

Now that the extension of the back-end is finished we want to emphasize on the positive effects of this.

As of now the compiler back-end works and can be built to a working compiler.
This new compiler supports the use of target flags which are |-mcpu=nux| and |-ms2pp|.
Also a new header file named |s2pp.h| exists and can be included the same way GCC standard header files are included.
Only together will this allow for using the |vector| attribute which creates vector variables of different types.

These vector variables specifically serve as arguments for newly implemented intrinsic functions that exist for every vector instruction which is available on nux.
Additionally the new intrinsics support type detection and map automatically to the according machine instruction for each vector type.

Assigning registers as well as memory works as expected and does not need for user interaction.
Despite the different bus, the back-end also rightfully accesses the synapse array when told to.
Specifically the user must use the intrinsics |fxv_inx| and |fxv_outx| to access the synapse array and load/store variables from/to there.

As many intrinsics as possible were designed according to existing intrinsics for AltiVec and use the |vec_| prefix as well a |fxv_| prefix.
For every previously available nux macro now exists an intrinsic function with the same name and the same arguments.

The compiler also supports coding in assembly using vector instructions without choosing hard registers but again loads and stores variables automatically and supports the constraints we implemented.
This will make it easier to combine low-level coding in high-level programs if this is ever needed.
One problem that was detected in this regard appears when choosing hard vector registers with |asm| which then are used in the output template.
It causes a replicable compiler error which should be addressed soon.
Besides that the compiler encountered various errors during development that had different origins.
One such error which often emerged was due to the overlapping register numbers with FPRs but could be fixed by adding a target dependency to register dependent actions and also adding prologue and epilogue functions which became necessary when compiling with optimization.
Other errors included non-matching RTL code and the compiler trying to move registers between GPRs and vector registers.
Many errors shaped the back-ends code but of course further testing could reveal unknown insufficiencies as bugs are constantly appearing for GCC as well.

Nonetheless, first tests which used intrinsics exclusively instead of macros produced working machine code as well as correct results.
Through these these early testing stages David StÃ¶kel was able to find a nux bug which previously was not known.
This thesis already referred to that bug which affects conditional usage of arithmetic instructions.
It also lead to the first in a newly proposed series of tests for nux which should check for more bugs like this in the near future.
Thanks to the |asm| support that nux gained these tests may not completely be written by hand but could be computer generated.

The compiler also supports different levels of optimization but tests for this are yet to come as checking for bugs caused by optimization is quite difficult.

Maybe the biggest question yet to answer is the reliability of the back-end as only correct code will be of any value.
Therefore this thesis highly encourages the implementation of automated tests and a simulation platform as currently tests can only be conducted on hardware which is not fully tested either.
This causes a conundrum where locating an error automatically is impossible.

Still there are ways of checking the correctness of code, mainly by reading the assembly output.
To illustrate this, listing \ref{fig:1stex} shows the comparison of newly written code that uses intrinsics, the assembly code that results from this with and without optimization and equivalent code that is written using the old |fxv.h| header file.

write an analysis of this



\add{
still compiles old code -> check this
works with libnux
is available in waf
some users are interested -> this will be a challenge
}
