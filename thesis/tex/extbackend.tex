\chapter{Extending the GCC Back-End}
\label{chapter:extbackend}
Since we now are familiar with the basics of processors, the PPU, compilers and GCC we can put this knowledge to use and start extending the GCC back-end.
There is a number of files we will systematically edit and keep referencing to as they are important parts of the rs6000 back-end and were changed in the process of extending the back-end. 
\begin{description}
    \item[rs6000.md] is the machine description of the back-end in general and contains insn definitions for all scalar functions
    \item[rs6000.h] is a header file which contains macros and declaration for registers
    \item[rs6000.c] is the source file which implements the back-end's functions
    \item[rs6000.opt] lists the options and flags for the target
    \item[rs6000-builtins.def] contains the definitions of intrinsics
    \item[rs6000-cpus.def] lists sub-targets that belong to the rs6000 family
    \item[rs6000-c.c] links built-ins and overloaded built-ins
    \item[rs6000-opts.h] contains a set of enumerations that represent option values for the back-end
    \item[rs6000-protos.h] makes functions in |rs6000.c| globally available
    \item[rs6000-tables.opt] lists values to a CPU enumeration
    \item[driver-rs6000.c] a collection of driver details for different targets
    \item[ppc-asm.h] sets macros for the use of |asm|
    \item[s2pp.md] is a new machine description of s2pp and contains insn definitions
    \item[s2pp.h] is the header file that defines aliases for built-ins
    \item[constraints.md] contains definitions of constraints
    \item[predicates.md] contains definitions of predicates
    \item[vector.md] defines general vector insns
    \item[sysv4.h] initializes a variety of option flags and sets default values
    \item[t-fprules] sets soft-float as default for certain targets
\end{description}

It is recommended to have chapter 5 of \citep{nux} at hand, as it contains an overview of existing s2pp vector instructions.

During the course of extending the GCC back-end a few things became clear:

Due to the limited documentation of the back-end itself, one must rely on comments in code and the GCC internals manual~\citep{GCCint} 
As a full implementation for a vector extension already exists, the AltiVec extension should be used as a guideline for a new extension. 
Still, it should be avoided to change exiting code as much as possible.
Code is often referred to from different places in the back-end and modifying existing code can therefore easily lead to compiler errors.
Especially since the back-end is not extended completely right away but rather step by step.
This applies particularly to functions that are implemented for AltiVec only.
It is recommended to rather duplicate functions and distinguish them before they are called, than doing so inside a function call.
This will make it to find bugs as usually the function that generates an error is indicated.
Also there do exist enough differences between these two vector extensions, that combining functions would not save work in the end.

Therefore we will occasionally point out when functions or other code can be inherited from AltiVec and which modifications are needed.

\section{Adding Option Flag and nux Target}
Extending the rs6000 back-end starts by adding the |nux| processor to the list of targets and also want to include mandatory flags with this.
Ideally the user only has to add the option flag |-mcpu=nux| when compiling in order to produce machine code for the nux.
The flags which have to be set when using the nux are:
\begin{description}
        \lstitem{-msdata=none}
        disables the use of a "small data section" which is like a data section but has a register constantly referring to it and thus has faster access than the normal data section. Globals, statics and small variables that are often used are preferably stored there.
        \lstitem{-mstrict-align}
        aligns all variables in memory which means that a variable always starts at a memory address without offset. Every variable requests at least 1 byte of memory when strictly aligned
        \lstitem{-msoft-float}
        tells the compiler that there is no FPU and all floating point operations have to simulated by software.
        \lstitem{-mno-relocatable}
        states that the program code has a fixed memory address that may not be altered.
\end{description}

But first there should be an option flag that activates nux' VE like |-maltivec| does for the AltiVec VE.
We chose the name |-ms2pp| for this new option flag and will define an option mask along with it.
In |rs6000.opt| and we simply need to add:
\begin{lstlisting}
ms2pp
Target Report Mask(S2PP) Var(rs6000_isa_flags)
Use s2pp instructions
\end{lstlisting}
This adds |ms2pp| to the list of option flags and the next lines defines a macro, that is associated with it.
|Target| means that the option is target specific, therefore only certain architectures support the option flag.
|Report| means that the option is to be printed when |-fverbose-asm| is is set.
|Mask(S2PP)| initializes a bitmask that is available through |OPTION_MASK_S2PP|.
That macro is attached to |rs6000_isa_flags|, which specified by |Var|.
It simultaneously specifies a macro |TARGET_S2PP| that is set to |1|. \cite{GCCint:options}

When this is done we need to specify 
\begin{lstlisting}
#define MASK_S2PP OPTION_MASK_S2PP
\end{lstlisting}
in |rs6000.h| as macros with |MASK_| are a standard from earlier versions of GCC.

Although this option flag shall later enable s2pp support, we need the aforementioned flags as well to compiler nux programs.
For this reason we add a processor type which combines those flags.
There exist several lists that contain available targets and we need to add nux to these.
First we create the |asm|~\ref{dection:asm} flag which tells the assembler which system architecture is used.
As nux is based on POWER7 we copy the flag |-mpower7| in |driver-rs6000.def|:

    \begin{lstlisting}[caption=rs6000.h]{Name}
    #define ASM_CPU_SPEC \
        ...
        %{mcpu=power7: %(asm_cpu_power7)} \
        ...
        %{mcpu=nux: %(asm_cpu_power7)} \
        ...
    \end{lstlisting}
    \begin{lstlisting}[caption=driver-rs6000.c]
    static const struct asm_name asm_names[] = {
        ...
        { "power7",   "%(asm_cpu_power7)" },
        ...
        { "nux",  "%(asm_cpu_power7)" },
        ...
    \end{lstlisting}

This will set the assembler |-mpower7| when using |-mcpu=nux|.

The nux target should also be recognized by preceding phases of the compiler and set option flags accordingly.
These options flags can be set in |rs6000-cpus.def|.

\begin{lstlisting}
...
RS6000_CPU ("nux", PROCESSOR_POWER7, MASK_SOFT_FLOAT | MASK_S2PP | MASK_STRICT_ALIGN | !MASK_RELOCATABLE)
\end{lstlisting}

This uses the macro |RS6000_CPU (NAME, CPU, FLAGS)| and adds |nux| to the |processor_target_table[]|.
Since we saw earlier that option flags usually set masks, we set the respective masks directly.
The masks we chose will tell the compiler that the processor is a POWER7 architecture and uses |soft-float|, |strict-align| and |no-relocatable|(negated relocatable) as well as the new s2pp mask.

Unfortunately we could not set the |-msdata=none| flag before since the |-msdata| flag is initialized differently.
Also since it is not simply set ``on'' or ``off'' but accepts several values, it is handled in |sysv4.h|.
|rs6000_sdata| will be set according to the string that follows |-msdata=|.
\begin{lstlisting}
#define SUBTARGET_OVERRIDE_OPTIONS                  \
...
 if (rs6000_sdata_name)                        \
     {                                   \
       if (!strcmp (rs6000_sdata_name, "none"))              \
     rs6000_sdata = SDATA_NONE;                  \
     ...
       else                              \
     error ("bad value for -msdata=%s", rs6000_sdata_name);      \
     }                                   \
 else if (OPTION_MASK_S2PP \
          && OPTION_MASK_SOFT_FLOAT \
          && OPTION_MASK_STRICT_ALIGN \
          && !OPTION_MASK_RELOCATABLE)                 \
     {                                   \
     rs6000_sdata = SDATA_NONE;                    \
     rs6000_sdata_name = "none";                   \
     }                                   \
else if (DEFAULT_ABI == ABI_V4)                   \
...
\end{lstlisting}

It is not possible to detect in this file, if the nux flag is set.
We therefore need a little work-around that helps setting the value of |rs6000_sdata|.
If |-msdata| is not set, i.e. only |-mcpu=nux| is set, the compiler will use |if|-clauses that determine which value is assigned to |rs6000_sdata|.
We add a case that checks for all flags, that are set by |-mcpu=nux| and set |rs6000_sdata| to |SDATA_NONE| if this applies.
Hence the target options will also set |rs6000_sdata| as we wish which is to |SDATA_NONE|.

There exists a case for which this condition applies even when |nux| is not set as target but all flags are set by hand.
If one chooses an explicit value for |-msdata| this case does not apply though and the value of |-msdata| is set accordingly.

This is somewhat not the ideal but a trade-off with as few side effects as possible.
\\
\\
Already this would allow for the use of |-mcpu=nux| as target and |-ms2pp| as option flag.
But since the flags we used are basically mandatory to the s2pp extension we also want to check for these flags before starting compilation.
First though for each flag are needed which the back-end can identify.
This is done in |rs6000-c.c| where global macros can be defined:

\begin{lstlisting}

void
rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,
                 HOST_WIDE_INT bu_mask)
{
  ...
  if ((flags & OPTION_MASK_S2PP) != 0)
   rs6000_define_or_undefine_macro (define_p, "__S2PP__");
  if ((flags & OPTION_MASK_STRICT_ALIGN) != 0)
   rs6000_define_or_undefine_macro (define_p, "_STRICT_ALIGN");
  if ((flags & OPTION_MASK_RELOCATABLE) != 0)
   rs6000_define_or_undefine_macro (define_p, "_RELOCATABLE");
  if (rs6000_sdata != SDATA_NONE)
   rs6000_define_or_undefine_macro (define_p, "_SDATA");
   ...
\end{lstlisting}

If |flags| and the respective option mask are set, |rs6000_define_or_undefine_macro| will define a macro what is specified by the second argument.
Whether a macro is defined or undefined depends on the boolean |define_p|, which is set by the compiler.

We can use these new macros to check if flags are set.
This needs a new file, that will also be needed later on as a header file for s2pp.
|s2pp,h| must be indexed in |gcc/config.gcc| under |extra_headers|.
\begin{lstlisting}
...
powerpc*-*-*)
    cpu_type=rs6000
    extra_headers="ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h htmintrin.h htmxlintrin.h s2pp.h"
    need_64bit_hwint=yes
    case x$with_cpu in
    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[345678]|xpower6x|xrs64a|xcell|xa2|xe500mc64|xe5500|Xe6500)
    cpu_is_64bit=yes
    ;;
    esac
    extra_options="${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt"
    ;;
...
\end{lstlisting}
This is done for GCC to invoke the header file as it is not referenced elsewhere.

|s2pp.h| can now be used to check the compiler flags.
\begin{lstlisting}
/* _S2PP_H */
#ifndef _S2PP_H
#define _S2PP_H 1

#if !defined(__S2PP__)
#error Use the "-ms2pp" flag to enable s2pp support
#endif
#if !defined(_SOFT_FLOAT)
#error Use the "-msoft-float" flag to enable s2pp support
#endif
#if !defined(_STRICT_ALIGN)
#error Use the "-mstrict-align" flag to enable s2pp support
#endif
#if defined(_RELOCATABLE)
#error Use the "-mno-relocatable" flag to enable s2pp support
#endif
#if defined(_SDATA)
#error Use the "-msdata=none" flag to enable s2pp support
#endif
...
\end{lstlisting}\unsure{one example for repetitive use?}

If for example |__S2PP__| is not defined but |s2pp.h| included, the compiler will emit an error that tells the user to set the target flag.
Since hard floats are not supported on |nux| regardless of |s2pp.h| we add nux to the list of soft-float CPUs in |t-fprules|.
\begin{lstlisting}
SOFT_FLOAT_CPUS = e300c2 401 403 405 440 464 476 ec603e 801 821 823 860 nux
\end{lstlisting}

\section{Creating Macros}
Since the preliminary requirements are now met, we start adding fundamental macros a |vector| attribute for specifying vectors in program code.

\textbf{Attributes} are used to specify various variables and can be used for example to control alignment \citep{GCCint:attributes}.

First a new vector unit is needed.
It will be called |VECTOR_S2PP| and added to the enumeration |rs6000_vector| in |rs6000-opts.h|.
\begin{lstlisting}
enum rs6000_vector {
      VECTOR_NONE,          /* Type is not  a vector or not supported */
      VECTOR_ALTIVEC,       /* Use altivec for vector processing */
      VECTOR_VSX,           /* Use VSX for vector processing */
      VECTOR_P8_VECTOR,     /* Use ISA 2.07 VSX for vector processing */
      VECTOR_PAIRED,        /* Use paired floating point for vectors */
      VECTOR_SPE,           /* Use SPE for vector processing */
      VECTOR_S2PP,          /* Use s2pp for vector processing */ //s2pp-mark
      VECTOR_OTHER          /* Some other vector unit */
};
\end{lstlisting}

To put this to use, we will create macros in |rs6000.h| which compare vector units to the newly created |VECTOR_S2PP|.
\begin{lstlisting}
...
#define VECTOR_UNIT_S2PP_P(MODE)            \
    (rs6000_vector_unit[(MODE)] == VECTOR_S2PP)
...
#define VECTOR_MEM_S2PP_P(MODE)             \
  (rs6000_vector_mem[(MODE)] == VECTOR_S2PP)
...
\end{lstlisting}

|VECTOR_UNIT_S2PP_P(MODE)| and |VECTOR_MEM_S2PP_P(MODE)| are identical as we will create identical entries for |rs6000_vector_unit[]| and |rs6000_vector_mem[]|.
This is a relict from AltiVec implementation as vector units in memory may differ in certain cases. \unsure{mention VSX?}

We will also add checking for specific vector modes which are supported by s2pp.
The hardware only supports two types of vectors which are vectors with byte elements (V16QI) and vectors with halfword elements (V8HI).
\begin{lstlisting}
#define S2PP_VECTOR_MODE(MODE)        \
         ((MODE) == V16QImode)        \
          ||  (MODE) == V8HImode)
\end{lstlisting}

Next we need to find conditions which easily apply to |TARGET_S2PP| as they already do for |TARGET_ALTIVEC|.
There exist only five such cases, |rs6000_builtin_vectorization_cost|, |rs6000_special_adjust_field_align_p| and |expand_block_clear| handle alignment of vectors.
\textbf{Alignment} refers to the position of data blocks in memory; 16-bit alignment means that variables may only start at addresses that represent multiples of 16 bits.
AltiVec vectors and s2pp are aligned the same way as we want to reduce misalignment of 128-bit vectors to a minimum.

|rs6000_common_init_builtins| initializes common built-ins (which we will later refer to) and is needed by all extensions that use built-ins.
In these cases we can simply expand the condition for |TARGET_S2PP|.

Other conditions that will later be expanded for |TARGET_S2PP| need further modification and thus are not mentioned here.

We must do the same for |VECTOR_UNIT_S2PP_P| and other macros that have AltiVec counterparts:
In |reg_offset_addressing_ok_p| cases for |V16QImode| and |V8HImode| return false if |VECTOR_MEM_S2PP_P| or the AltiVec version apply.
In |rs6000_legitimize_reload_address| and |rs6000_legitimate_address_p| offset addresses are handled they same way they are for AltiVec.
In |rs6000_secondary_reload| indirect addressing is enforced.
In |print_operand| operand modifier |y| is validated for s2pp as well.
|rs6000_vector_mode_supported_p| returns true is a mode is supported by s2pp.

All of these cases handle addressing of vectors in memory which is equivalent in AltiVec and s2pp.
It is therefore quite simple to support this for s2pp.
\\
\\
Since we established vector modes and vector units by now, we need to connect these in |rs6000_init_hard_regno_mode_ok|.
In case |TARGET_S2PP| is set |VECTOR_S2PP| is assigned to modes |V16QImode| and |V8HImode|.
\begin{lstlisting}
...
  if (TARGET_S2PP)
      {
      rs6000_vector_unit[V8HImode] = VECTOR_S2PP;
      rs6000_vector_mem[V8HImode] = VECTOR_S2PP;
      rs6000_vector_align[V8HImode] = align32;
      rs6000_vector_unit[V16QImode] = VECTOR_S2PP;
      rs6000_vector_mem[V16QImode] = VECTOR_S2PP;
      rs6000_vector_align[V16QImode] = align32;
      }
...
\end{lstlisting}

Also preferred modes when vectorizing a non-vector modes in |rs6000_preferred_simd_mode|.
\begin{lstlisting}
...
  if (TARGET_S2PP)
    switch (mode)
        {
        case HImode:
      return V8HImode;
        case QImode:
      return V16QImode;
        default:;
        }
... 
\end{lstlisting}

By now we can define a vector attribute as we mentioned before.
GCC already supports a vector attribute which is also used by AltiVec.
Thus we can add s2pp to the |rs6000_attribute_table| and |rs6000_opt_masks[]| array with the same values as for AltiVec but changing the keyword.
\begin{lstlisting}
static const struct attribute_spec rs6000_attribute_table[] =
{
    /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,
         affects_type_identity } */
    { "altivec",   1, 1, false, true,  false, rs6000_handle_altivec_attribute,
      false },
    { "s2pp",   1, 1, false, true,  false, rs6000_handle_s2pp_attribute,
      false },
...
struct rs6000_opt_mask {
  const char *name;     /* option name */
  HOST_WIDE_INT mask;       /* mask to set */
  bool invert;          /* invert sense of mask */
  bool valid_target;        /* option is a target option */
};

static struct rs6000_opt_mask const rs6000_opt_masks[] =
{
  { "altivec",          OPTION_MASK_ALTIVEC,        false, true  },
  ...
  { "s2pp",         OPTION_MASK_S2PP,       false, true  },
  ...
\end{lstlisting}

We also add the function |rs6000_handle_s2pp_attribute| which is copied form AltiVec but stripped off unsupported vector modes.

This would make these attributes already usable but we also define built-ins in |rs6000-c.c| that shorten the attribute from |__vector=__attribute__((s2pp(vector__)))| to |__vector|:
\begin{lstlisting}
void
rs6000_cpu_cpp_builtins (cpp_reader *pfile)
{
  ...
  if (TARGET_S2PP){
     builtin_define ("__vector=__attribute__((s2pp(vector__)))");
     if (!flag_iso){
        builtin_define ("vector=vector");
        init_vector_keywords ();
        /* Enable context-sensitive macros.  */
        cpp_get_callbacks (pfile)->macro_to_expand = rs6000_macro_to_expand;
     }
  }
... 
\end{lstlisting}

Additionally we indicate to the front-end that special attributes are handled by the back-end.
\begin{lstlisting}
static bool
rs6000_attribute_takes_identifier_p (const_tree attr_id)
{
  if (TARGET_S2PP)
    return is_attribute_p ("s2pp", attr_id);
  else
    return is_attribute_p ("altivec", attr_id);
}
\end{lstlisting}

\section{Registers}
\label{section:register}
This section will describe, how s2pp registers are added to the back-end.
Also, we will add constraints and predicates \ref{sec:definsn} for these registers.

There are three types of registers in the s2pp VE:
\begin{description}
    \item[32 vector registers] these are normal registers that hold vector values
    \item[1 accumulator] which is used for chaining arithmetic instructions and cannot be accessed directly
    \item[1 conditional register] which holds conditional bits and also cannot be accessed directly
\end{description}

During extension of the GCC back-end, it became apparent that a reserved vector register, that is all zeros the entire time, will be necessary for some implementations of the back-end.
This became necessary since the nux instruction set does not include logical vector instructions.
Normally the instructions |XOR| and |OR| are used by the back-end to implement simple register features.
|OR| is used for moving around the content of a register as |OR|ing the same first register to a second register will simply copy the contents of the first register.
On the other side, does |XOR|ing the same register result in writing all zeros to the return register.\ref{section:asm}

Since these instructions are not available, ``nulling'' a register becomes a problem.
Therefore we reserve the first register and splat zeros into it.
Moving this register, will have the same effect as |XOR|ing a register.
As |OR| is also not available, we use an alternative instruction, which is |fxvselect|.
|fxvselect| selects either elements of the second or the third operand depending on the condition register and its forth operand\citep{nux}.
Having identical second and third operands thus will simply generate the same vector as return value.
By setting the forth operand |0|, |fxvselect| will always choose elements from the second operand.
This gives us a simple work-around as |fxvselect| also takes only one clock cycle for execution.
An alternative idea would be subtracting the same register from one another with |fxvsubm|, which also nulls the return operand.
This would take more clock cycles though and is unfavorable, as we do not know how often registers need to be nulled.
Ultimately it is a trade-off between having one less register at hand and wasting clock cycles continuously.
The latter could get easily more of a problem than the first one and therefore we will implement the first alternative.

When talking about reserved registers must also think about saved, call-used and fixed registers:
\begin{description}
    \item[fixed registers] serve only one purpose and are not available for allocation at all!
    \item[call-used registers] are used for returning results of functions. They are not available to general register allocation but are used when calling functions.
    \item[saved registers] are available globally and may hold values throughout function calls.
\end{description}

Usually about half of all registers is declared call-used and the other half saved.
We will stick to this convention but in the future it might be interesting to optimize this.
\\
\\
Register indexes are declared in |rs6000.md|:
\begin{lstlisting}
(define_constants
  [(FIRST_GPR_REGNO     0)
...
   (LAST_GPR_REGNO      31)
   (FIRST_FPR_REGNO     32)
   (LAST_FPR_REGNO      63)
   (FIRST_S2PP_REGNO    33)
   (LAST_S2PP_REGNO     63)
   (S2PP_COND_REGNO     32)
   (S2PP_ACC_REGNO      64)
   (LR_REGNO            65)
...])
\end{lstlisting}

We reuse the reserved vector register's index 32 (this register is null) for the conditional register and use the free index for the accumulator.
Registers which may be available on the same processor must not share and index!
As the GPRs need the first 32 registers numbers (0-31) and there is never an FPU on nux, we want to use the 32 registers normally reserved to FPRs.

We must define which purpose the registers will serve in the back-end.
This is declared by macros that are assigned a register number like in |rs6000.md|.
\begin{lstlisting}
/* Minimum and maximum s2pp registers used to hold arguments.  */
#define S2PP_ARG_MIN_REG (FIRST_S2PP_REGNO + 2)
#define S2PP_ARG_MAX_REG (S2PP_ARG_MIN_REG + 12)
#define S2PP_ARG_NUM_REG (S2PP_ARG_MAX_REG - S2PP_ARG_MIN_REG + 1)
...
#define S2PP_ARG_RETURN S2PP_ARG_MIN_REG
...
#define S2PP_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2 ? S2PP_ARG_RETURN \
                    : (S2PP_ARG_RETURN + AGGR_ARG_NUM_REG - 1))
...

#define FUNCTION_VALUE_REGNO_P(N)                   \
  ((N) == GP_ARG_RETURN                         \
     || ((N) >= FP_ARG_RETURN && (N) <= FP_ARG_MAX_RETURN         \
         && TARGET_HARD_FLOAT && TARGET_FPRS)             \
     || ((N) >= ALTIVEC_ARG_RETURN && (N) <= ALTIVEC_ARG_MAX_RETURN   \
         && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI)             \
     || ((N) >= S2PP_ARG_RETURN && (N) <= S2PP_ARG_MAX_RETURN     \
         && TARGET_S2PP)              \
     )
...
#define FUNCTION_ARG_REGNO_P(N)                     \
  ((unsigned) (N) - GP_ARG_MIN_REG < GP_ARG_NUM_REG         \
     || ((unsigned) (N) - ALTIVEC_ARG_MIN_REG < ALTIVEC_ARG_NUM_REG   \
         && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI)             \
     || ((unsigned) (N) - FP_ARG_MIN_REG < FP_ARG_NUM_REG         \
         && TARGET_HARD_FLOAT && TARGET_FPRS)             \
     || ((unsigned) (N) - S2PP_ARG_MIN_REG < S2PP_ARG_NUM_REG     \
         && TARGET_S2PP)              \
     )
...
\end{lstlisting}

Of course we again need to go through all files and find usage of those macros.
The only use the macros though is in the prologue and the epilogue, which will be discussed in the next section.

After we declared all register indexes, we must also specify them further.
Each register type (or register class) needs and entry to the enumeration |reg_class| and a definition of identical register names in |REG_CLASS_NAMES|.
\begin{lstlisting}
enum reg_class
{
  ...
  GENERAL_REGS,
  S2PP_C_REG,
  S2PP_REGS,
  FLOAT_REGS,
  S2PP_ACC_REG,
  ALTIVEC_REGS,
  ...}
...
#define REG_CLASS_NAMES                         \
  {                                   \
  ...
  "GENERAL_REGS",                           \
  "S2PP_C_REG",                             \
  "S2PP_REGS",                              \
  "FLOAT_REGS",                             \
  "S2PP_ACC_REG",                           \
  "ALTIVEC_REGS",                           \
  ...
  "ALL_REGS"}
  \end{lstlisting}\unsure{in columns?}

Then we need to specify the contents of our new register classes in |REG_CLASS_CONTENTS|.
\begin{lstlisting}
/* GENERAL_REGS.  */                          \
{ 0xffffffff, 0x00000000, 0x00000008, 0x00020000, 0x00000000 },   \
/* S2PP_C_REG.  */                                                \
{ 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },   \
/* S2PP_REGS.  */                                                 \
{ 0x00000000, 0xfffffffe, 0x00000000, 0x00000000, 0x00000000 },   \
/* FLOAT_REGS.  */                                                \
{ 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000 },   \
/* S2PP_ACC_REG.  */                                              \
{ 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000 },   \
/* ALTIVEC_REGS.  */
{ 0x00000000, 0x00000000, 0xffffe000, 0x00001fff, 0x00000000 },   \
...
/* ALL_REGS.  */                          \
{ 0xffffffff, 0xffffffff, 0xffffffff, 0xffe7ffff, 0xffffffff }}
\end{lstlisting}

Each hexnumber in these arrays can be viewed as a bit mask where the least significant bit is the first register, the next higher order bit the second register and so on.
As a number is 32-bit, it masks 32 registers.
Subsequent numbers start where the previous one ended, therefore are registers 32 through 63 (32 is the 33rd register) masked by the second number.

Therefore does |0xfffffffe| mask all registers except for the 32nd which is masked by |0x00000001|.

One can see that FPRs are masked completely as |FLOAT_REGS| between definition of s2pp registers.
Subsequent entries must not me subsets of previous masks but may extend these.
Also should higher order bits follow lower order bits.
Since we also added a register index which was not masked before, we also have to change some subsequent masks accordingly.

There exist macros for register classes as well, which we also need to implement.
Although we only need this for general s2pp registers.
\begin{lstlisting}
...
#define S2PP_REG_CLASS_P(CLASS)         \
    ((CLASS) == S2PP_REGS)
...
\end{lstlisting}

As all registers are specified we now have to decide on short names, that are used in assembly.
Normally these are the same as the constraints that refer to these registers and an integer.

The constraints are:
\begin{description}
        \lstitem{kv} for |S2PP_REGS|, the vector registers
        \lstitem{kc} for |S2PP_C_REG|, the conditional register
        \lstitem{ka} for |S2PP_ACC_REG|, the accumulator
\end{description}

|k| was chosen as the first character of s2pp constraints because there are very few letters left which are not used as constraints already.
|k| is the first of those and can be somewhat associated with the nux (``nuks'').
The second character is the respective first letter of a register type.

Register names are defined in |rs6000.h|.
\begin{lstlisting}
#define ADDITIONAL_REGISTER_NAMES \
{
  ...
  {"kc", 32}, {"kv0",  33}, {"kv1",  34}, {"kv2",  35},   \
  ...
  {"kv27", 60}, {"kv28", 61}, {"kv29", 62}, {"kv30", 63},   \
  {"kc", 64}, {"ka", 65}                \
}
\end{lstlisting}
The strings are names for registers and the integers are their indexes.
\\
\\
After we defined these names we can also define the according constraints in |constraints.md|
\begin{lstlisting}
(define_register_constraint "kv" "rs6000_constraints[RS6000_CONSTRAINT_kv]"
  "s2pp vector register")

(define_register_constraint "kc" "rs6000_constraints[RS6000_CONSTRAINT_kc]"
  "s2pp conditional register")

(define_register_constraint "ka" "rs6000_constraints[RS6000_CONSTRAINT_ka]"
  "s2pp accumulator")
\end{lstlisting}

The first string is the register constraint's name and the second string will be assigned a register class later in |rs6000.c|.
The last string is only for documentary purposes.\cite{GCCint:constraints}

Before we can assign register classes though, we must modify an enumeration in |rs6000.h|
\begin{lstlisting}
enum r6000_reg_class_enum {
  ...
  RS6000_CONSTRAINT_v,      /* Altivec registers */
  RS6000_CONSTRAINT_kv,     /* s2pp vector regsiters*/
  RS6000_CONSTRAINT_kc,     /* s2pp conditional register*/
  RS6000_CONSTRAINT_ka,     /* s2pp accumulator*/
  ...
};
\end{lstlisting}

The last step towards completing the register implementation is assigning register classes and register types to indexes in |rs6000_init_hard_regno_mode_ok|.

Register types are also defined in |rs6000.c| and help classifying register classes.
The s2pp registers we defined in this section qualify as standard and vector register type and thus are added to these macros.
\begin{lstlisting}
enum rs6000_reg_type {
  ...
  FPR_REG_TYPE,
  S2PP_REG_TYPE,
  ...
  S2PP_C_REG_TYPE,
  S2PP_ACC_REG_TYPE,
  ...
};
...
#define IS_STD_REG_TYPE(RTYPE) IN_RANGE(RTYPE, GPR_REG_TYPE, S2PP_REG_TYPE)
...
#define IS_FP_VECT_REG_TYPE(RTYPE) IN_RANGE(RTYPE, VSX_REG_TYPE, S2PP_REG_TYPE)
...
static void
rs6000_init_hard_regno_mode_ok (bool global_init_p)
{
  ...
  for (r = 32; r < 64; ++r)
    rs6000_regno_regclass[r] = FLOAT_REGS;

  if (TARGET_S2PP){
    for (r = 32+1; r < 64; ++r)
      rs6000_regno_regclass[r] = S2PP_REGS;
    rs6000_regno_regclass[32] = NO_REGS;
  }
  ...
  reg_class_to_reg_type[(int)S2PP_REGS] = S2PP_REG_TYPE;
  ...
  if (TARGET_S2PP)
    {
    reg_class_to_reg_type[(int)FLOAT_REGS] = NO_REG_TYPE; //S2PP_REG_TYPE;
    reg_class_to_reg_type[(int)S2PP_REGS] = S2PP_REG_TYPE; //S2PP_REG_TYPE;
    rs6000_regno_regclass[S2PP_COND_REGNO] = S2PP_C_REG;
    rs6000_regno_regclass[S2PP_ACC_REGNO] = S2PP_ACC_REG;
    reg_class_to_reg_type[(int)S2PP_C_REG] = S2PP_C_REG_TYPE; //S2PP_REG_TYPE;
    reg_class_to_reg_type[(int)S2PP_ACC_REG] = S2PP_ACC_REG_TYPE; //S2PP_REG_TYPE;
    }
  ...
  if (TARGET_S2PP)
    {
    rs6000_vector_unit[V8HImode] = VECTOR_S2PP;
    rs6000_vector_mem[V8HImode] = VECTOR_S2PP;
    rs6000_vector_align[V8HImode] = align32;
    rs6000_vector_unit[V16QImode] = VECTOR_S2PP;
    rs6000_vector_mem[V16QImode] = VECTOR_S2PP;
    rs6000_vector_align[V16QImode] = align32;
    }
  ...
  if (TARGET_S2PP){
    rs6000_constraints[RS6000_CONSTRAINT_kv] = S2PP_REGS;
    rs6000_constraints[RS6000_CONSTRAINT_kc] = S2PP_C_REG;
    rs6000_constraints[RS6000_CONSTRAINT_ka] = S2PP_ACC_REG;
  }
  ...
}
\end{lstlisting}

Every index in |rs6000_regno_regclass[]| is given a register class which corresponds to a register with the same index and also each register class is assigned a register type in |reg_class_to_reg_type[]|.

What is left to do, is fixing the registers:
\begin{lstlisting}
static void
rs6000_conditional_register_usage (void)
{
  ...
  if ((TARGET_SOFT_FLOAT || !TARGET_FPRS) && !TARGET_S2PP)
    for (i = 32; i < 64; i++)
      fixed_regs[i] = call_used_regs[i]
                    = call_really_used_regs[i] = 1;

  if (TARGET_S2PP){
    fixed_regs[32] = call_used_regs[32] = call_really_used_regs[32] = 1;
    fixed_regs[64] = call_used_regs[64] = call_really_used_regs[64] = 1;
  }
  ...
}
\end{lstlisting}
We need to prevent the back-end form fixing the FPRs even though |TARGET_SOFT_FLOAT| is set and fix the registers 32 and 64 (|kc| and |ka|).

We can also add debugging information for s2pp registers in |rs6000_debug_reg_global|.
Although this is not necessary, it can be helpful at times, when using the |-mdebug| flag.
\\
\\
As all measures of adding the registers to |rs6000.c| we need to add them to the list of possible |asm| operands in 
|ppx-asm.c| where a simple definition like |#define k0 1| is enough if this is done for each register name.
This tells the compiler to substitute |k0| for 1 as only pure integers are valid machine operands.

The last step to completing register usage for the back-end is adding fitting predicates in |predicates.md|.
We can copy these from the respective AltiVec predicates and change both the vector specific macros and the predicates' names.
The affected predicates are:
\begin{description}
        \lstitem{s2pp_register_operand} is a vector that is stored in a s2pp register
        \lstitem{easy_vector_constant} returns 1 if the operand is a constant vector and now also tests for s2pp vectors and calls a new function |easy_s2pp_constant|
        \lstitem{indexed_or_indirect_operand} applies for indexed or indirect operands (e.g. memory addresses in registers) and now supports the case of a s2pp vector operand as for AltiVec vectors
        \lstitem{s2pp_indexed_or_indirect_operand} is the same but only for s2pp vectors, not AltiVec
\end{description}
If one wants to add own predicates, GCC offers a manuals entry \cite{GCCint:predicates}.

The |easy_s2pp_constant| function checks if an operand is ``splittable'' which means that all elements are the same and thus can be generated through a split instruction.
To check this the operand is analyzed sequentially if either of the two available splats can synthesize the same operand.
This was also transferable from an AltiVec equivalent with the exception that one vector mode had to be removed.
prologue epilogue
Additionally the similar function |gen_easy_s2pp_constant| could also be transfered as it works the same way but generates RTL code that will create a constant vector operand from a different operand.

Now as we have completely added the new registers, we must take care of some consequences this caused.
Mainly our problem is that we reused the floating point registers and did not mark them as fixed \reference{earlier}.
For this reason we must scan the source files for |FP_REGNO_P(N)| and add an exception with |&& !TARGET_S2PP| when it is necessary.
This is especially the case when dealing with hard registers and having the compiler emit register moves.

\section{Prologue and Epilogue}
Also we have a second problem that reusing FPR indexes causes.
Since there is an ending number of registers the compiler can use for saving values, and this number is also reduced by the amount of fixed registers, the compiler occasionally stores values in memory before calling a function that needs some of the available registers by calling a so called ``prologue'' \citep{GCCint:funcentry}.
The compiler then restores the registers after the function has finished through an ``epilogue''.
To understand the principles of these we will take a look at how the back-end saves registers.
Before the compiler saves the registers it must check which registers need to be saved.
It then sets a variable for each register type accordingly.
In |rs6000_emit_prologue| the compiler checks for these variables and starts saving the respective registers.
Since the compilers looks for register numbers instead of types, we need to alter the case for FPRs and add a target flag, which activates these lines of code:
\begin{lstlisting}
for (i = 0; info->first_s2pp_reg_save + i <= LAST_S2PP_REGNO; i++)
    if (save_reg_p (info->first_s2pp_reg_save + i)){

        int offset = frame_off + 16 * i;
        rtx savereg = gen_rtx_REG (V8HImode, i+info->first_s2pp_reg_save);
        rtx areg = gen_rtx_REG (Pmode, 0);
        emit_move_insn (areg, GEN_INT (offset));
        rtx mem = gen_frame_mem (V8HImode,gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));
        insn = emit_move_insn (mem, savereg);
        rs6000_frame_related (insn, frame_reg_rtx, sp_off-frame_off, areg,
                                GEN_INT(offset), NULL_RTX);
    }
\end{lstlisting}
The compiler first loops over every save vector register and checks if the register needs to be stored.
Then an offset is computed that takes the current frame offset and adds 16 bytes(this is the register size) for every register of this type.
|savereg| and |areg| are two kinds of register that will later serve as operands.
|savereg| is the vector register we want to save and |areg| will we the GPR operand needed to use vector memory instructions\reference{fxvstax and fxvlax}
Hence |areg| loads the offset just calculated through |emit_move_insn|.
|emit_move_insn| will then insert an insn to the IR that moves the second argument to the first.
Now we can create a complete memory operand |mem| that takes |offset| in |areg| and |frame_reg_rtx|, which is the register holding the frame pointer to wheres all registers are saved, and combines them to a single operand.
As both register and memory are specified the compiler can emit a move insn that stores |savereg| to |mem|.
Finally |rs6000_frame_related| handles the insn which was just created and performs additional customizations which are needed as the moves belong to a function call.
After the functions code has been compiled the back-end invokes |rs6000_emit_epilogue| which uses the same functions as the prologue but restores the registers from memory.
Of course this function can not work on its but needs other functions that set parameters and prepare statements as well.
These functions were also extended by adding conditional cases for s2pp that mostly agree with the respective AltiVec cases.
An |rtx|, which was a type often used in the previous listing, is short for RTL expression and can be used by |insn|s as an argument.
RTL expressions can also contain information on how the operand is to be constructed as this allows chaining of operations.

\section{Reload}
As hinted in chapter \ref{chapter:methods} |reload| is a now deprecated process in GCC that mainly performs register allocation.
Obviously we need to add special handling of vector registers to |reload| because the registers we just added to the back-end must be used somehow.
We thus get back to |S2PP_REGS| which were the normal vector register form earlier.
As |reload| is capable of moving the contents of registers, we must specify that s2pp's registers are not compatible with GPRs or any other registers and also that storing/loading registers takes two GPRs that hold the memory address.
Because registers are quite different in their specifications and reload could possibly ask for any combination of source/destination register we declare only registers moves between s2pp registers only or between s2pp registers and memory valid.
This also creates the need for checking the register class of an RTL expression and eventually correcting the register class.
Additionally as |reload| does not support the addressing mode which AltiVec and s2pp both use, we must rearrange indirect addresses the same way AltiVec does.
At last we also need to validate the mode which is used.
All of this is done in a set of  |rs6000_secondary_reload_| functions which need to be modified.

\section{Built-ins and Machine Instructions}
Basically the back-end is now almost compatible with s2pp vector instructions.
The only thing that is left is specifying the machine instructions which move registers or access memory.
We therefore add a machine description file |s2pp.md| to the back-end which will contain all available vector instructions.
On which is |*s2pp_mov<mode>|:
\begin{lstlisting}
(define_insn "*s2pp_mov<mode>"
  [(set (match_operand:FXVI 0 "nonimmediate_operand" "=Z,kv,kv,*Y,*r,*r,kv,kv")
   (match_operand:FXVI 1 "input_operand" "kv,Z,kv,r,Y,r,j,W"))]
  "VECTOR_MEM_S2PP_P (<MODE>mode)
   && (register_operand (operands[0], <MODE>mode) 
   || register_operand (operands[1], <MODE>mode))"
  { 
   switch (which_alternative)
    {
    case 0: return "fxvstax %1,%y0";
    case 1: return "fxvlax %0,%y1";
    case 2: return "fxvsel %0,%1,%1";
    case 3: return "#";
    case 4: return "#";
    case 5: return "#";
    case 6: return "fxvsel %0,0,0";
    case 7: return output_vec_const_move (operands);
    default: gcc_unreachable ();
    }
  } 
  [(set_attr "type" "vecstore,vecload,vecsimple,store,load,*,vecsimple,*")])
\end{lstlisting}

We explained the basics of insn definition earlier in section \ref{section:insn} thus we will only explain this shortly.
The name is proceeded by an asterisk that renders the name not accessible directly because this insn shall only be referred to by the RTL sequence that follows.
The sequence is fairly simple and states that operand |0| is set by operand |1|.
It only gets interesting when taking a look at the constraints which build pairs for each operand and are separated by commas.
The first pair for example (|=Z| and |kv|) tells the compiler that a memory which is accessed by an indirect operand will be set by the contents of a vector register (this is the first use of our new constraint.
Which machine instruction is used for each pair of constraints is stated in the output template which may also be in C form.
Each case is indexed according to the position in the list of constraints so we take a look at |case 0| where we see the matching machine instruction for storing a vector in memory |fxvstax|.
The second operand contains also a character besides its number which is an operand modifier \cite{GCCint:asm} that will cause the operand |0| to be split into two address operands.
Besides the vector load instruction |fxvlax| we also note the |fxvsel| instruction which is used to move one vector register to another(pair |kv| and |kv|) and |case 6| which moves the contents of vector register |0| (this register is all |0|s) and thereby nulls that register.
The constraint |j| is the respective constraint for a zero vector.

But still there exist instruction which are not specified in detail but only by ``|#|''.
A |#| is the equivalent to stating that there is no instruction which can perform the instruction which is described by the RTL above.
This causes the compiler to look for different RTL that has the same effect but also has a machine instruction.

This process is called ``insn splitting'' and can also be used for optimization.
A developer may also define which RTL statements are equivalent by using |define_split| which is documented in \cite{GCCint:definesplit}.
As there exist splits for cases 3 through 5 in AltiVec, we may not define splits ourself.

Splitting insns is quite common for the GCC back-end because splitting insns with unspecific constraints allows for easier generation of code, since the back-end will search for code that fits the operands of the instruction which is called in the source files.
Even |s2pp_mov| is mainly used by calling a general vector move insn in |vector.md| that has the same RTL code without any constraints and then is split.
We only need to add the s2pp vector mode macro to the condition of the insn which is specified through |define_expand "mov<mode>|.
Expanding an insn which is done for this code basically follows the principle of splitting and goes even further in not giving the option for a machine instruction at all but relies on matching RTL in some machine description of the back-end.
Detailed information can be acquired in \cite{GCCint:defineexpand}.

As this is done for register moves is general we will do the same for specific loads and stores, by adding mode checking in |vector.md| and adding a matching insn to |s2pp.md|.

Beside adding the other insns we also need to add the function |rs6000_address_for_s2pp| which converts a standard address to an s2pp compatible form.
This code could be taken from an AltiVec equivalent since both vector units share the same form of memory referencing.

Now before we continue to other insns, we shall go back to |s2pp_mov| and take a look at |case 7| which applies for constant vectors.
Constant vectors which have a constant value that does not depend on a register thus is known at compile time.
GCC will look for such vectors and check if these vectors can be splatted (this means all vector elements have the same value).
This is a relict of AltiVec which offers a special splat instruction that takes a constant immediate value as operand.
We kept the function since we can achieve a similar effect for constant zero vectors by moving the zero register.
To distinguish between cases where this applies, we use the function |output_vec_const_move()| which is also used by AltiVec and implemented similar code to the existing AltiVec code but reduced this to the null vector case and emit a |#| for splitting otherwise.

Since we are now missing an instruction to use this split we will create a split ourselves which converts the immediate splat into a normal splat:
\begin{lstlisting}
(define_split
  [(set (match_operand:FXVI 0 "s2pp_register_operand" "")
   (match_operand:FXVI 1 "easy_vector_constant" ""))]
  "TARGET_S2PP && can_create_pseudo_p()"
  [(set (match_dup 2) (match_dup 3))
   (set (match_dup 0) (unspec:FXVI [(match_dup 2)] UNSPEC_FXVSPLAT))]
  "{
   operands[2] = gen_reg_rtx (SImode);
   operands[3] = CONST_VECTOR_ELT(operands[1], 1);
   }")
\end{lstlisting}

We split the upper RTL sequence which moves a constant vector to a vector register onto the bottom sequence which inserts an intermediate step.
|match_dup n| means that the operand should match the operand with the same index.
The C code that follows specifies the newly added operands 2 and 3 further and converts operand |1| into a single integer element because all values are the same.
The second RTL sequence uses the newly created integer and moves it to a GPR which then is splatted into a vector register.
An |unspec| operator together with |UNSPEC_...| tells the compiler that the operation is not specified but has a name to distinguish is from other unspecified operations.

\begin{lstlisting}
(define_insn "*s2pp_fxvsplat<FXVI_char>"
  [(set (match_operand:FXVI 0 "register_operand" "=kv")
   (unspec:FXVI
         [(match_operand:SI 1 "register_operand" "r")] UNSPEC_FXVSPLAT))]
  "TARGET_S2PP"
  "fxvsplat<FXVI_char> %0,%1"
  [(set_attr "type" "vecperm")])
\end{lstlisting}
is the insn the split refers to.

After we finally added memory instructions we can also implement them in |rs6000.c|.
In |rs6000_init_hard_regno_mode_ok| we assign the code for store and load instructions to the two supported modes in case the target flag is set but do not specify any others.

All that is left now are intrinsic functions that make use of the memory instructions.
Although by now the compiler would already support |asm| usage as shown in \ref{section:asm} and which we will get back to later on.
Still we do not want to stop there and also add intrinsic functions to the back-end.
This is done through several steps that were also described in an internship report \cite{heimbrecht_2017internship}.
Therefore we will only describe this briefly and refer to the report at times.

First we start defining insns for each vector instruction that is listed in \cite{nuxmanual}.
In order to allow access to the synram we implement insns that work similar to |fxvstax| and |fxvlax| and are called |fxvoutx| and |fxvinx|.
All of these insns exist with different conditionals and are named accordingly because load and store insns are hard to implement with an additional argument that is the conditional.
Simple arithmetic instructions exist in multiple versions that either support conditional execution or do not.
This is due to a problem that was discovered only recently with the PPU.
As tests revealed the conditional execution of arithmetic instructions works improperly and in case a condition does not apply the result of a previous instruction is written to the first operand.
Normally the operation should leave the contents of the operand untouched instead.
For this reason we implement a workaround through insn splits that utilizes |fxvselect| and its conditional execution as this does work as intended.
Though we still offer arithmetic operations without splits as this saves a clock cycle in comparison to having an additional |fxvselect| instruction.
Besides those simple arithmetic operations, |fxvadd...|, |fxvsub...| and |fxvmul...|, there also exist more complex operations that make use of the accumulator.
As of now these instructions should not be used with conditionals as further testing is imminent and it is not clear whether those conditionals would work.
Besides that does an extra instruction render the advantages of an accumulator meaningless.
Nonetheless do we implement those accumulator instructions together with a conditional argument which would allow for easier testing later on.
Also does the additional operand not influence the performance of the instruction in a bad manner since for the conditional |0| the instruction works the same as if the conditional was true for all elements.

We will refer back to this when discussing the results of extending the back-end.

Since this completes the insns we can go on and create built-ins in |rs6000-builtins.def| from these insns.
First though we must add macros that makes adding intrinsics easier.
The exact definition of those macros is described for AltiVec built-ins in \cite{heimbrecht_2017internship} but we can easily transfer those for s2pp by adding the |RS6000_BTM_S2PP| built-in mask which is identical with the target mask.
We then use the s2pp built-in macros to create built-in definitions for each insn and also each mode (halfword or byte).
Most built-ins follow the scheme of a normal function that has a result and a certain number of arguments.
Btu there exists a number of insns that do not produce an output as they set the accumulator or the conditional register.
These instructions need special handling and thus are defined as special built-ins.

Besides defining built-ins we also define overloads.
These are used to differ intrinsics through the types of their arguments later on what makes using them easier and stops false usage.
Overloads are also further explained in \cite{heimbrecht_2017internship}
As we are adding overloads we can put them to use in |rs6000-c.c| where overloads and built-ins are connected.
This is done through structures that combine the built-in and overload names with a return type and up to three arguments.

To actually make use of these structures, we will add a function to |rs6000-c.c| that resolves the overloaded built-ins and is again built upon an AltiVec function that does the very same.
Therefore we must tell the back-end which functions to use by making a target dependent decision in |rs6000.h| which overload-resolving function is handling overloads in general.
Also we need a functions in |rs6000.c| that handle built-ins in general.
First we create a new function |s2pp_expand_builtin| which is invoked by |rs6000_expand_builtin|.
This function handles all special built-ins that belong to s2pp and picks expander functions according to their name.
We therefore must create those expander functions that take care of certain kinds of built-ins.
One such group are memory intrinsics that handle explicit memory addressing and also apply to synram intrinsics.
These expanders are needed because of the special way that memory is accessed through indirect register referencing.
As for the operand modifiers we can use the same implementation that AltiVec uses but create a new function in case improvements may become necessary at some point in time.

Besides these expander functions we additionally create a new kind of expander function that did not exist before s2pp.
As there is a great number of instructions that do not return any values because they write the accumulator or the conditional registers, we create expander functions for various numbers of arguments that each do not handle a return operand.
These functions which were called |s2pp_expand_unaryx_bultin|, |s2pp_expand_binaryx_bultin| and |s2pp_expand_ternaryx_bultin| otherwise behave quite similar.

Now that we are already handling special built-ins we need to define those built-ins in |rs6000.c| as well.
|s2pp_init_bultins| takes care of that as it is a series of |define_builtin| functions which must be written explicitly in contrast to normal built-in functions, where this is done automatically.

We did not mention so far the special case of three other built-in function that belong to the group of special built-ins as well but differ in how the RTL code/machine instructions are generated.
|vec_ext|, |vec_init| and |vec_promote| describe functions which do not belong to a specific vector instruction but are compiler-constructed sequences of machine instructions that correspond to a certain action on a vector which is mainly performed in memory.
These functions are inspired by AltiVec's implementation which easily was transferable to s2pp.

Finally we conclude on built-ins by defining alternative names for built-in functions in |s2pp.h|.

A complete list of all intrinsic functions that the compiler supports at the time this thesis was written is available in the appendix \ref{appendix:builtinlist}.

\add{
    ?
target pragmas compiler anweisung
stack boundary -> put this together
frame offsetr
stackoffset
fix pck instructions 
}
