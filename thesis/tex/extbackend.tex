\chapter{Extending the GCC Back-End}
\label{chapter:extbackend}
Since we now are familiar with the basics of processors, the PPU, compilers and GCC we can put this knowledge to use and start extending the GCC back-end.
There is a number of files we will systematically edit and keep referencing to as they are important parts of the rs6000 back-end and were changed in the process of extending the back-end. 
\begin{description}
    \item[rs6000.md] is the machine description of the back-end in general and contains insn definitions for all scalar functions
    \item[rs6000.h] is a header file which contains macros and declaration for registers
    \item[rs6000.c] is the source file which implements the back-end's functions
    \item[rs6000.opt] lists the options and flags for the target
    \item[rs6000-builtins.def] contains the definitions of intrinsics
    \item[rs6000-cpus.def] lists sub-targets that belong to the rs6000 family
    \item[rs6000-c.c] links built-ins and overloaded built-ins
    \item[rs6000-opts.h] contains a set of enumerations that represent option values for the back-end
    \item[rs6000-protos.h] makes functions in |rs6000.c| globally available
    \item[rs6000-tables.opt] lists values to a CPU enumeration
    \item[driver-rs6000.c] a collection of driver details for different targets
    \item[ppc-asm.h] sets macros for the use of |asm|
    \item[s2pp.md] is a new machine description of s2pp and contains insn definitions
    \item[s2pp.h] is the header file that defines aliases for built-ins
    \item[constraints.md] contains definitions of constraints
    \item[predicates.md] contains definitions of predicates
    \item[vector.md] defines general vector insns
    \item[sysv4.h] initializes a variety of option flags and sets default values
    \item[t-fprules] sets soft-float as default for certain targets
\end{description}

It is recommended to have chapter 5 of \citep{nux} at hand, as it contains an overview of existing s2pp vector instructions.

During the course of extending the GCC back-end a few things became clear:

Due to the limited documentation of the back-end itself, one must rely on comments in code and the GCC internals manual~\citep{GCCint} 
As a full implementation for a vector extension already exists, the AltiVec extension should be used as a guideline for a new extension. 
Still, it should be avoided to change exiting code as much as possible.
Code is often referred to from different places in the back-end and modifying existing code can therefore easily lead to compiler errors.
Especially since the back-end is not extended completely right away but rather step by step.
This applies particularly to functions that are implemented for AltiVec only.
It is recommended to rather duplicate functions and distinguish them before they are called, than doing so inside a function call.
This will make it to find bugs as usually the function that generates an error is indicated.
Also there do exist enough differences between these two vector extensions, that combining functions would not save work in the end.

Therefore we will occasionally point out when functions or other code can be inherited from AltiVec and which modifications are needed.

\section{Adding Option Flag and nux Target}
Extending the rs6000 back-end starts by adding the |nux| processor to the list of targets and also want to include mandatory flags with this.
Ideally the user only has to add the option flag |-mcpu=nux| when compiling in order to produce machine code for the nux.
The flags which have to be set when using the nux are:
\begin{description}
        \lstitem{-msdata=none}
        disables the use of a "small data section" which is like a data section but has a register constantly referring to it and thus has faster access than the normal data section. Globals, statics and small variables that are often used are preferably stored there.
        \lstitem{-mstrict-align}
        aligns all variables in memory which means that a variable always starts at a memory address without offset. Every variable requests at least 1 byte of memory when strictly aligned
        \lstitem{-msoft-float}
        tells the compiler that there is no FPU and all floating point operations have to simulated by software.
        \lstitem{-mno-relocatable}
        states that the program code has a fixed memory address that may not be altered.
\end{description}

But first there should be an option flag that activates nux' VE like |-maltivec| does for the AltiVec VE.
We chose the name |-ms2pp| for this new option flag and will define an option mask along with it.
In |rs6000.opt| and we simply need to add:
\begin{lstlisting}
ms2pp
Target Report Mask(S2PP) Var(rs6000_isa_flags)
Use s2pp instructions
\end{lstlisting}
This adds |ms2pp| to the list of option flags and the next lines defines a macro, that is associated with it.
|Target| means that the option is target specific, therefore only certain architectures support the option flag.
|Report| means that the option is to be printed when |-fverbose-asm| is is set.
|Mask(S2PP)| initializes a bitmask that is available through |OPTION_MASK_S2PP|.
That macro is attached to |rs6000_isa_flags|, which specified by |Var|.
It simultaneously specifies a macro |TARGET_S2PP| that is set to |1|. \citep{GCCint:options}

When this is done we need to specify 
\begin{lstlisting}
#define MASK_S2PP OPTION_MASK_S2PP
\end{lstlisting}
in |rs6000.h| as macros with |MASK_| are a standard from earlier versions of GCC.

Although this option flag shall later enable s2pp support, we need the aforementioned flags as well to compiler nux programs.
For this reason we add a processor type which combines those flags.
There exist several lists that contain available targets and we need to add nux to these.
First we create the inline assembly (see section~\ref{section:asm}) flag which tells the assembler which system architecture is used.
As nux is based on POWER7 we copy the flag |-mpower7| in |driver-rs6000.def|:

    \begin{lstlisting}[caption=rs6000.h]{Name}
    #define ASM_CPU_SPEC \
        ...
        %{mcpu=power7: %(asm_cpu_power7)} \
        ...
        %{mcpu=nux: %(asm_cpu_power7)} \
        ...
    \end{lstlisting}
    \begin{lstlisting}[caption=driver-rs6000.c]
    static const struct asm_name asm_names[] = {
        ...
        { "power7",   "%(asm_cpu_power7)" },
        ...
        { "nux",  "%(asm_cpu_power7)" },
        ...
    \end{lstlisting}

This will set the assembler |-mpower7| when using |-mcpu=nux|.

The nux target should also be recognized by preceding phases of the compiler and set option flags accordingly.
These options flags can be set in |rs6000-cpus.def|.

\begin{lstlisting}
...
RS6000_CPU ("nux", PROCESSOR_POWER7, MASK_SOFT_FLOAT | MASK_S2PP | MASK_STRICT_ALIGN | !MASK_RELOCATABLE)
\end{lstlisting}

This uses the macro |RS6000_CPU (NAME, CPU, FLAGS)| and adds |nux| to the |processor_target_table[]|.
Since we saw earlier that option flags usually set masks, we set the respective masks directly.
The masks we chose will tell the compiler that the processor is a POWER7 architecture and uses |soft-float|, |strict-align| and |no-relocatable|(negated relocatable) as well as the new s2pp mask.

Unfortunately we could not set the |-msdata=none| flag before since the |-msdata| flag is initialized differently.
Also since it is not simply set ``on'' or ``off'' but accepts several values, it is handled in |sysv4.h|.
|rs6000_sdata| will be set according to the string that follows |-msdata=|.
\begin{lstlisting}
#define SUBTARGET_OVERRIDE_OPTIONS                  \
...
 if (rs6000_sdata_name)                        \
     {                                   \
       if (!strcmp (rs6000_sdata_name, "none"))              \
     rs6000_sdata = SDATA_NONE;                  \
     ...
       else                              \
     error ("bad value for -msdata=%s", rs6000_sdata_name);      \
     }                                   \
 else if (OPTION_MASK_S2PP \
          && OPTION_MASK_SOFT_FLOAT \
          && OPTION_MASK_STRICT_ALIGN \
          && !OPTION_MASK_RELOCATABLE)                 \
     {                                   \
     rs6000_sdata = SDATA_NONE;                    \
     rs6000_sdata_name = "none";                   \
     }                                   \
else if (DEFAULT_ABI == ABI_V4)                   \
...
\end{lstlisting}

It is not possible to detect in this file, if the nux flag is set.
We therefore need a little work-around that helps setting the value of |rs6000_sdata|.
If |-msdata| is not set, i.e. only |-mcpu=nux| is set, the compiler will use |if|-clauses that determine which value is assigned to |rs6000_sdata|.
We add a case that checks for all flags, that are set by |-mcpu=nux| and set |rs6000_sdata| to |SDATA_NONE| if this applies.
Hence the target options will also set |rs6000_sdata| as we wish which is to |SDATA_NONE|.

There exists a case for which this condition applies even when |nux| is not set as target but all flags are set by hand.
If one chooses an explicit value for |-msdata| this case does not apply though and the value of |-msdata| is set accordingly.

This is somewhat not the ideal but a trade-off with as few side effects as possible.
\\
\\
Already this would allow for the use of |-mcpu=nux| as target and |-ms2pp| as option flag.
But since the flags we used are basically mandatory to the s2pp extension we also want to check for these flags before starting compilation.
First though for each flag are needed which the back-end can identify.
This is done in |rs6000-c.c| where global macros can be defined:

\begin{lstlisting}

void
rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,
                 HOST_WIDE_INT bu_mask)
{
  ...
  if ((flags & OPTION_MASK_S2PP) != 0)
   rs6000_define_or_undefine_macro (define_p, "__S2PP__");
  if ((flags & OPTION_MASK_STRICT_ALIGN) != 0)
   rs6000_define_or_undefine_macro (define_p, "_STRICT_ALIGN");
  if ((flags & OPTION_MASK_RELOCATABLE) != 0)
   rs6000_define_or_undefine_macro (define_p, "_RELOCATABLE");
  if (rs6000_sdata != SDATA_NONE)
   rs6000_define_or_undefine_macro (define_p, "_SDATA");
   ...
\end{lstlisting}

If |flags| and the respective option mask are set, |rs6000_define_or_undefine_macro| will define a macro what is specified by the second argument.
Whether a macro is defined or undefined depends on the boolean |define_p|, which is set by the compiler.

We can use these new macros to check if flags are set.
This needs a new file, that will also be needed later on as a header file for s2pp.
|s2pp,h| must be indexed in |gcc/config.gcc| under |extra_headers|.
\begin{lstlisting}
...
powerpc*-*-*)
    cpu_type=rs6000
    extra_headers="ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h htmintrin.h htmxlintrin.h s2pp.h"
    need_64bit_hwint=yes
    case x$with_cpu in
    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[345678]|xpower6x|xrs64a|xcell|xa2|xe500mc64|xe5500|Xe6500)
    cpu_is_64bit=yes
    ;;
    esac
    extra_options="${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt"
    ;;
...
\end{lstlisting}
This is done for GCC to invoke the header file as it is not referenced elsewhere.

|s2pp.h| can now be used to check the compiler flags.
\begin{lstlisting}
/* _S2PP_H */
#ifndef _S2PP_H
#define _S2PP_H 1

#if !defined(__S2PP__)
#error Use the "-ms2pp" flag to enable s2pp support
#endif
#if !defined(_SOFT_FLOAT)
#error Use the "-msoft-float" flag to enable s2pp support
#endif
#if !defined(_STRICT_ALIGN)
#error Use the "-mstrict-align" flag to enable s2pp support
#endif
#if defined(_RELOCATABLE)
#error Use the "-mno-relocatable" flag to enable s2pp support
#endif
#if defined(_SDATA)
#error Use the "-msdata=none" flag to enable s2pp support
#endif
...
\end{lstlisting}\unsure{one example for repetitive use?}

If for example |__S2PP__| is not defined but |s2pp.h| included, the compiler will emit an error that tells the user to set the target flag.
Since hard floats are not supported on |nux| regardless of |s2pp.h| we add nux to the list of soft-float CPUs in |t-fprules|.
\begin{lstlisting}
SOFT_FLOAT_CPUS = e300c2 401 403 405 440 464 476 ec603e 801 821 823 860 nux
\end{lstlisting}

\section{Creating Macros}
Since the preliminary requirements are now met, we start adding fundamental macros a |vector| attribute for specifying vectors in program code.

\textbf{Attributes} are used to specify various variables and can be used for example to control alignment \citep{GCCint:attributes}.

First a new vector unit is needed.
It will be called |VECTOR_S2PP| and added to the enumeration |rs6000_vector| in |rs6000-opts.h|.
\begin{lstlisting}
enum rs6000_vector {
      VECTOR_NONE,          /* Type is not  a vector or not supported */
      VECTOR_ALTIVEC,       /* Use altivec for vector processing */
      VECTOR_VSX,           /* Use VSX for vector processing */
      VECTOR_P8_VECTOR,     /* Use ISA 2.07 VSX for vector processing */
      VECTOR_PAIRED,        /* Use paired floating point for vectors */
      VECTOR_SPE,           /* Use SPE for vector processing */
      VECTOR_S2PP,          /* Use s2pp for vector processing */ //s2pp-mark
      VECTOR_OTHER          /* Some other vector unit */
};
\end{lstlisting}

To put this to use, we will create macros in |rs6000.h| which compare vector units to the newly created |VECTOR_S2PP|.
\begin{lstlisting}
...
#define VECTOR_UNIT_S2PP_P(MODE)            \
    (rs6000_vector_unit[(MODE)] == VECTOR_S2PP)
...
#define VECTOR_MEM_S2PP_P(MODE)             \
  (rs6000_vector_mem[(MODE)] == VECTOR_S2PP)
...
\end{lstlisting}

|VECTOR_UNIT_S2PP_P(MODE)| and |VECTOR_MEM_S2PP_P(MODE)| are identical as we will create identical entries for |rs6000_vector_unit[]| and |rs6000_vector_mem[]|.
This is a relict from AltiVec implementation as vector units in memory may differ in certain cases. \unsure{mention VSX?}

We will also add checking for specific vector modes which are supported by s2pp.
The hardware only supports two types of vectors which are vectors with byte elements (V16QI) and vectors with halfword elements (V8HI).
\begin{lstlisting}
#define S2PP_VECTOR_MODE(MODE)        \
         ((MODE) == V16QImode)        \
          ||  (MODE) == V8HImode)
\end{lstlisting}

Next we need to find conditions which easily apply to |TARGET_S2PP| as they already do for |TARGET_ALTIVEC|.
There exist only five such cases, |rs6000_builtin_vectorization_cost|, |rs6000_special_adjust_field_align_p| and |expand_block_clear| handle alignment of vectors.
\textbf{Alignment} refers to the position of data blocks in memory; 16-bit alignment means that variables may only start at addresses that represent multiples of 16 bits.
AltiVec vectors and s2pp are aligned the same way as we want to reduce misalignment of 128-bit vectors to a minimum.

|rs6000_common_init_builtins| initializes common built-ins (which we will later refer to) and is needed by all extensions that use built-ins.
In these cases we can simply expand the condition for |TARGET_S2PP|.

Other conditions that will later be expanded for |TARGET_S2PP| need further modification and thus are not mentioned here.

We must do the same for |VECTOR_UNIT_S2PP_P| and other macros that have AltiVec counterparts:
In |reg_offset_addressing_ok_p| cases for |V16QImode| and |V8HImode| return false if |VECTOR_MEM_S2PP_P| or the AltiVec version apply.
In |rs6000_legitimize_reload_address| and |rs6000_legitimate_address_p| offset addresses are handled they same way they are for AltiVec.
In |rs6000_secondary_reload| indirect addressing is enforced.
In |print_operand| operand modifier |y| is validated for s2pp as well.
|rs6000_vector_mode_supported_p| returns true is a mode is supported by s2pp.

All of these cases handle addressing of vectors in memory which is equivalent in AltiVec and s2pp.
It is therefore quite simple to support this for s2pp.
\\
\\
Since we established vector modes and vector units by now, we need to connect these in |rs6000_init_hard_regno_mode_ok|.
In case |TARGET_S2PP| is set |VECTOR_S2PP| is assigned to modes |V16QImode| and |V8HImode|.
\begin{lstlisting}
...
  if (TARGET_S2PP)
      {
      rs6000_vector_unit[V8HImode] = VECTOR_S2PP;
      rs6000_vector_mem[V8HImode] = VECTOR_S2PP;
      rs6000_vector_align[V8HImode] = align32;
      rs6000_vector_unit[V16QImode] = VECTOR_S2PP;
      rs6000_vector_mem[V16QImode] = VECTOR_S2PP;
      rs6000_vector_align[V16QImode] = align32;
      }
...
\end{lstlisting}

Also preferred modes when vectorizing a non-vector modes in |rs6000_preferred_simd_mode|.
\begin{lstlisting}
...
  if (TARGET_S2PP)
    switch (mode)
        {
        case HImode:
      return V8HImode;
        case QImode:
      return V16QImode;
        default:;
        }
... 
\end{lstlisting}

By now we can define a vector attribute as we mentioned before.
GCC already supports a vector attribute which is also used by AltiVec.
Thus we can add s2pp to the |rs6000_attribute_table| and |rs6000_opt_masks[]| array with the same values as for AltiVec but changing the keyword.
\begin{lstlisting}
static const struct attribute_spec rs6000_attribute_table[] =
{
    /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,
         affects_type_identity } */
    { "altivec",   1, 1, false, true,  false, rs6000_handle_altivec_attribute,
      false },
    { "s2pp",   1, 1, false, true,  false, rs6000_handle_s2pp_attribute,
      false },
...
struct rs6000_opt_mask {
  const char *name;     /* option name */
  HOST_WIDE_INT mask;       /* mask to set */
  bool invert;          /* invert sense of mask */
  bool valid_target;        /* option is a target option */
};

static struct rs6000_opt_mask const rs6000_opt_masks[] =
{
  { "altivec",          OPTION_MASK_ALTIVEC,        false, true  },
  ...
  { "s2pp",         OPTION_MASK_S2PP,       false, true  },
  ...
\end{lstlisting}

We also add the function |rs6000_handle_s2pp_attribute| which is copied form AltiVec but stripped off unsupported vector modes.

This would make these attributes already usable but we also define built-ins in |rs6000-c.c| that shorten the attribute from |__vector=__attribute__((s2pp(vector__)))| to |__vector|:
\begin{lstlisting}
void
rs6000_cpu_cpp_builtins (cpp_reader *pfile)
{
  ...
  if (TARGET_S2PP){
     builtin_define ("__vector=__attribute__((s2pp(vector__)))");
     if (!flag_iso){
        builtin_define ("vector=vector");
        init_vector_keywords ();
        /* Enable context-sensitive macros.  */
        cpp_get_callbacks (pfile)->macro_to_expand = rs6000_macro_to_expand;
     }
  }
... 
\end{lstlisting}

Additionally we indicate to the front-end that special attributes are handled by the back-end.
\begin{lstlisting}
static bool
rs6000_attribute_takes_identifier_p (const_tree attr_id)
{
  if (TARGET_S2PP)
    return is_attribute_p ("s2pp", attr_id);
  else
    return is_attribute_p ("altivec", attr_id);
}
\end{lstlisting}

\section{Registers}
\label{section:register}
This section will describe, how s2pp registers are added to the back-end.
Also, we will add constraints and predicates (see section~\ref{sec:defineinsn}) for these registers.

There are three types of registers in the s2pp VE:
\begin{description}
    \item[32 vector registers] these are normal registers that hold vector values
    \item[1 accumulator] which is used for chaining arithmetic instructions and cannot be accessed directly
    \item[1 conditional register] which holds conditional bits and also cannot be accessed directly
\end{description}

During extension of the GCC back-end, it became apparent that a reserved vector register, that is all zeros the entire time, will be necessary for some implementations of the back-end.
This became necessary since the nux instruction set does not include logical vector instructions.
Normally the instructions |XOR| and |OR| are used by the back-end to implement simple register features.
|OR| is used for moving around the content of a register as |OR|ing the same first register to a second register will simply copy the contents of the first register.
On the other side, does |XOR|ing the same register result in writing all zeros to the return register.\ref{section:asm}

Since these instructions are not available, ``nulling'' a register becomes a problem.
Therefore we reserve the first register and splat zeros into it.
Moving this register, will have the same effect as |XOR|ing a register.
As |OR| is also not available, we use an alternative instruction, which is |fxvselect|.
|fxvselect| selects either elements of the second or the third operand depending on the condition register and its forth operand\citep{nux}.
Having identical second and third operands thus will simply generate the same vector as return value.
By setting the forth operand |0|, |fxvselect| will always choose elements from the second operand.
This gives us a simple work-around as |fxvselect| also takes only one clock cycle for execution.
An alternative idea would be subtracting the same register from one another with |fxvsubm|, which also nulls the return operand.
This would take more clock cycles though and is unfavorable, as we do not know how often registers need to be nulled.
Ultimately it is a trade-off between having one less register at hand and wasting clock cycles continuously.
The latter could get easily more of a problem than the first one and therefore we will implement the first alternative.

When talking about reserved registers must also think about saved, call-used and fixed registers:
\begin{description}
    \item[fixed registers] serve only one purpose and are not available for allocation at all!
    \item[call-used registers] are used for returning results of functions. They are not available to general register allocation but are used when calling functions.
    \item[saved registers] are available globally and may hold values throughout function calls.
\end{description}

Usually about half of all registers is declared call-used and the other half saved.
We will stick to this convention but in the future it might be interesting to optimize this.
\\
\\
Register indexes are declared in |rs6000.md|:
\begin{lstlisting}
(define_constants
  [(FIRST_GPR_REGNO     0)
...
   (LAST_GPR_REGNO      31)
   (FIRST_FPR_REGNO     32)
   (LAST_FPR_REGNO      63)
   (FIRST_S2PP_REGNO    33)
   (LAST_S2PP_REGNO     63)
   (S2PP_COND_REGNO     32)
   (S2PP_ACC_REGNO      64)
   (LR_REGNO            65)
...])
\end{lstlisting}

We reuse the reserved vector register's index 32 (this register is null) for the conditional register and use the free index for the accumulator.
Registers which may be available on the same processor must not share and index!
As the GPRs need the first 32 registers numbers (0-31) and there is never an FPU on nux, we want to use the 32 registers normally reserved to FPRs.

We must define which purpose the registers will serve in the back-end.
This is declared by macros that are assigned a register number like in |rs6000.md|.
\begin{lstlisting}
/* Minimum and maximum s2pp registers used to hold arguments.  */
#define S2PP_ARG_MIN_REG (FIRST_S2PP_REGNO + 2)
#define S2PP_ARG_MAX_REG (S2PP_ARG_MIN_REG + 12)
#define S2PP_ARG_NUM_REG (S2PP_ARG_MAX_REG - S2PP_ARG_MIN_REG + 1)
...
#define S2PP_ARG_RETURN S2PP_ARG_MIN_REG
...
#define S2PP_ARG_MAX_RETURN (DEFAULT_ABI != ABI_ELFv2 ? S2PP_ARG_RETURN \
                    : (S2PP_ARG_RETURN + AGGR_ARG_NUM_REG - 1))
...

#define FUNCTION_VALUE_REGNO_P(N)                   \
  ((N) == GP_ARG_RETURN                         \
     || ((N) >= FP_ARG_RETURN && (N) <= FP_ARG_MAX_RETURN         \
         && TARGET_HARD_FLOAT && TARGET_FPRS)             \
     || ((N) >= ALTIVEC_ARG_RETURN && (N) <= ALTIVEC_ARG_MAX_RETURN   \
         && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI)             \
     || ((N) >= S2PP_ARG_RETURN && (N) <= S2PP_ARG_MAX_RETURN     \
         && TARGET_S2PP)              \
     )
...
#define FUNCTION_ARG_REGNO_P(N)                     \
  ((unsigned) (N) - GP_ARG_MIN_REG < GP_ARG_NUM_REG         \
     || ((unsigned) (N) - ALTIVEC_ARG_MIN_REG < ALTIVEC_ARG_NUM_REG   \
         && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI)             \
     || ((unsigned) (N) - FP_ARG_MIN_REG < FP_ARG_NUM_REG         \
         && TARGET_HARD_FLOAT && TARGET_FPRS)             \
     || ((unsigned) (N) - S2PP_ARG_MIN_REG < S2PP_ARG_NUM_REG     \
         && TARGET_S2PP)              \
     )
...
\end{lstlisting}

Of course we again need to go through all files and find usage of those macros.
The only use the macros though is in the prologue and the epilogue, which will be discussed in the next section.

After we declared all register indexes, we must also specify them further.
Each register type (or register class) needs and entry to the enumeration |reg_class| and a definition of identical register names in |REG_CLASS_NAMES|.
\begin{lstlisting}
enum reg_class
{
  ...
  GENERAL_REGS,
  S2PP_C_REG,
  S2PP_REGS,
  FLOAT_REGS,
  S2PP_ACC_REG,
  ALTIVEC_REGS,
  ...}
...
#define REG_CLASS_NAMES                         \
  {                                   \
  ...
  "GENERAL_REGS",                           \
  "S2PP_C_REG",                             \
  "S2PP_REGS",                              \
  "FLOAT_REGS",                             \
  "S2PP_ACC_REG",                           \
  "ALTIVEC_REGS",                           \
  ...
  "ALL_REGS"}
  \end{lstlisting}\unsure{in columns?}

Then we need to specify the contents of our new register classes in |REG_CLASS_CONTENTS|.
\begin{lstlisting}
/* GENERAL_REGS.  */                          \
{ 0xffffffff, 0x00000000, 0x00000008, 0x00020000, 0x00000000 },   \
/* S2PP_C_REG.  */                                                \
{ 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },   \
/* S2PP_REGS.  */                                                 \
{ 0x00000000, 0xfffffffe, 0x00000000, 0x00000000, 0x00000000 },   \
/* FLOAT_REGS.  */                                                \
{ 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000 },   \
/* S2PP_ACC_REG.  */                                              \
{ 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000 },   \
/* ALTIVEC_REGS.  */
{ 0x00000000, 0x00000000, 0xffffe000, 0x00001fff, 0x00000000 },   \
...
/* ALL_REGS.  */                          \
{ 0xffffffff, 0xffffffff, 0xffffffff, 0xffe7ffff, 0xffffffff }}
\end{lstlisting}

Each hexnumber in these arrays can be viewed as a bit mask where the least significant bit is the first register, the next higher order bit the second register and so on.
As a number is 32-bit, it masks 32 registers.
Subsequent numbers start where the previous one ended, therefore are registers 32 through 63 (32 is the 33rd register) masked by the second number.

Therefore does |0xfffffffe| mask all registers except for the 32nd which is masked by |0x00000001|.

One can see that FPRs are masked completely as |FLOAT_REGS| between definition of s2pp registers.
Subsequent entries must not me subsets of previous masks but may extend these.
Also should higher order bits follow lower order bits.
Since we also added a register index which was not masked before, we also have to change some subsequent masks accordingly.

There exist macros for register classes as well, which we also need to implement.
Although we only need this for general s2pp registers.
\begin{lstlisting}
...
#define S2PP_REG_CLASS_P(CLASS)         \
    ((CLASS) == S2PP_REGS)
...
\end{lstlisting}

As all registers are specified we now have to decide on short names, that are used in assembly.
Normally these are the same as the constraints that refer to these registers and an integer.

The constraints are:
\begin{description}
        \lstitem{kv} for |S2PP_REGS|, the vector registers
        \lstitem{kc} for |S2PP_C_REG|, the conditional register
        \lstitem{ka} for |S2PP_ACC_REG|, the accumulator
\end{description}

|k| was chosen as the first character of s2pp constraints because there are very few letters left which are not used as constraints already.
|k| is the first of those and can be somewhat associated with the nux (``nuks'').
The second character is the respective first letter of a register type.

Register names are defined in |rs6000.h|.
\begin{lstlisting}
#define ADDITIONAL_REGISTER_NAMES \
{
  ...
  {"kc", 32}, {"kv0",  33}, {"kv1",  34}, {"kv2",  35},   \
  ...
  {"kv27", 60}, {"kv28", 61}, {"kv29", 62}, {"kv30", 63},   \
  {"kc", 64}, {"ka", 65}                \
}
\end{lstlisting}
The strings are names for registers and the integers are their indexes.
\\
\\
After we defined these names we can also define the according constraints in |constraints.md|
\begin{lstlisting}
(define_register_constraint "kv" "rs6000_constraints[RS6000_CONSTRAINT_kv]"
  "s2pp vector register")

(define_register_constraint "kc" "rs6000_constraints[RS6000_CONSTRAINT_kc]"
  "s2pp conditional register")

(define_register_constraint "ka" "rs6000_constraints[RS6000_CONSTRAINT_ka]"
  "s2pp accumulator")
\end{lstlisting}

The first string is the register constraint's name and the second string will be assigned a register class later in |rs6000.c|.
The last string is only for documentary purposes.\citep{GCCint:constraints}

Before we can assign register classes though, we must modify an enumeration in |rs6000.h|
\begin{lstlisting}
enum r6000_reg_class_enum {
  ...
  RS6000_CONSTRAINT_v,      /* Altivec registers */
  RS6000_CONSTRAINT_kv,     /* s2pp vector regsiters*/
  RS6000_CONSTRAINT_kc,     /* s2pp conditional register*/
  RS6000_CONSTRAINT_ka,     /* s2pp accumulator*/
  ...
};
\end{lstlisting}

The last step towards completing the register implementation is assigning register classes and register types to indexes in |rs6000_init_hard_regno_mode_ok|.

Register types are also defined in |rs6000.c| and help classifying register classes.
The s2pp registers we defined in this section qualify as standard and vector register type and thus are added to these macros.
\begin{lstlisting}
enum rs6000_reg_type {
  ...
  FPR_REG_TYPE,
  S2PP_REG_TYPE,
  ...
  S2PP_C_REG_TYPE,
  S2PP_ACC_REG_TYPE,
  ...
};
...
#define IS_STD_REG_TYPE(RTYPE) IN_RANGE(RTYPE, GPR_REG_TYPE, S2PP_REG_TYPE)
...
#define IS_FP_VECT_REG_TYPE(RTYPE) IN_RANGE(RTYPE, VSX_REG_TYPE, S2PP_REG_TYPE)
...
static void
rs6000_init_hard_regno_mode_ok (bool global_init_p)
{
  ...
  for (r = 32; r < 64; ++r)
    rs6000_regno_regclass[r] = FLOAT_REGS;

  if (TARGET_S2PP){
    for (r = 32+1; r < 64; ++r)
      rs6000_regno_regclass[r] = S2PP_REGS;
    rs6000_regno_regclass[32] = NO_REGS;
  }
  ...
  reg_class_to_reg_type[(int)S2PP_REGS] = S2PP_REG_TYPE;
  ...
  if (TARGET_S2PP)
    {
    reg_class_to_reg_type[(int)FLOAT_REGS] = NO_REG_TYPE; //S2PP_REG_TYPE;
    reg_class_to_reg_type[(int)S2PP_REGS] = S2PP_REG_TYPE; //S2PP_REG_TYPE;
    rs6000_regno_regclass[S2PP_COND_REGNO] = S2PP_C_REG;
    rs6000_regno_regclass[S2PP_ACC_REGNO] = S2PP_ACC_REG;
    reg_class_to_reg_type[(int)S2PP_C_REG] = S2PP_C_REG_TYPE; //S2PP_REG_TYPE;
    reg_class_to_reg_type[(int)S2PP_ACC_REG] = S2PP_ACC_REG_TYPE; //S2PP_REG_TYPE;
    }
  ...
  if (TARGET_S2PP)
    {
    rs6000_vector_unit[V8HImode] = VECTOR_S2PP;
    rs6000_vector_mem[V8HImode] = VECTOR_S2PP;
    rs6000_vector_align[V8HImode] = align32;
    rs6000_vector_unit[V16QImode] = VECTOR_S2PP;
    rs6000_vector_mem[V16QImode] = VECTOR_S2PP;
    rs6000_vector_align[V16QImode] = align32;
    }
  ...
  if (TARGET_S2PP){
    rs6000_constraints[RS6000_CONSTRAINT_kv] = S2PP_REGS;
    rs6000_constraints[RS6000_CONSTRAINT_kc] = S2PP_C_REG;
    rs6000_constraints[RS6000_CONSTRAINT_ka] = S2PP_ACC_REG;
  }
  ...
}
\end{lstlisting}

Every index in |rs6000_regno_regclass[]| is given a register class which corresponds to a register with the same index and also each register class is assigned a register type in |reg_class_to_reg_type[]|.

What is left to do, is fixing the registers:
\begin{lstlisting}
static void
rs6000_conditional_register_usage (void)
{
  ...
  if ((TARGET_SOFT_FLOAT || !TARGET_FPRS) && !TARGET_S2PP)
    for (i = 32; i < 64; i++)
      fixed_regs[i] = call_used_regs[i]
                    = call_really_used_regs[i] = 1;

  if (TARGET_S2PP){
    fixed_regs[32] = call_used_regs[32] = call_really_used_regs[32] = 1;
    fixed_regs[64] = call_used_regs[64] = call_really_used_regs[64] = 1;
  }
  ...
}
\end{lstlisting}
We need to prevent the back-end form fixing the FPRs even though |TARGET_SOFT_FLOAT| is set and fix the registers 32 and 64 (|kc| and |ka|).

We can also add debugging information for s2pp registers in |rs6000_debug_reg_global|.
Although this is not necessary, it can be helpful at times, when using the |-mdebug| flag.

As all measures of adding the registers to |rs6000.c| are fulfilled one must add those registers to the list of possible |asm| operands in |ppx-asm.c|.
\begin{lstlisting}
#ifdef __S2PP__
#define k00 0
#define k0  1
...
#define k29 30
#define k30 31
#endif
\end{lstlisting}
This tells the compiler to substitute |k0| for 1 as only integers without constraints are valid machine operands.

All that is missing now, are s2pp specific predicates in |predicates.md|.
We can copy these from respective AltiVec predicates and change both the vector specific macros and the predicates' names.
\begin{lstlisting}
...
(define_predicate "s2pp_register_operand"
  (match_operand 0 "register_operand")
{
  if (GET_CODE (op) == SUBREG)
    op = SUBREG_REG (op);

  if (!REG_P (op))
    return 0;

  if (REGNO (op) > LAST_VIRTUAL_REGISTER)
    return 1;

  return S2PP_REGNO_P (REGNO (op));
})
...
(define_predicate "easy_vector_constant"
  (match_code "const_vector")
{
  ...
  if (VECTOR_MEM_S2PP_P (mode))
    {
  if (zero_constant (op, mode))
    return true;

  return easy_s2pp_constant (op, mode);
    }
  ...
})
...
(define_predicate "indexed_or_indirect_operand"
  (match_code "mem")
{
  ...
  if (VECTOR_MEM_S2PP_P (mode)
      && GET_CODE (op) == AND
      && GET_CODE (XEXP (op, 1)) == CONST_INT
      && INTVAL (XEXP (op, 1)) == -16)
    op = XEXP (op, 0);

  return indexed_or_indirect_address (op, mode);
})
...
(define_predicate "s2pp_indexed_or_indirect_operand"
  (match_code "mem")
{
  op = XEXP (op, 0);
  if (VECTOR_MEM_S2PP_P (mode)
      && GET_CODE (op) == AND
      && GET_CODE (XEXP (op, 1)) == CONST_INT
      && INTVAL (XEXP (op, 1)) == -16)
    return indexed_or_indirect_address (XEXP (op, 0), mode);

  return 0;
})
...    
\end{lstlisting}
If one wants to add more predicates, GCC offers a manuals entry \citep{GCCint:predicates}.

The |easy_s2pp_constant| function, which is referred to in the listing above, checks if an operand is ``splittable'', ergo that all elements have the same value and the operand can be synthesized through a split instruction.
To check this the operand is analyzed sequentially if either of the two available splat instructions can synthesize the same operand.
This function is transferable from an AltiVec equivalent with the exception that there is one less alternative for splatting a vector.
\begin{lstlisting}
bool
easy_s2pp_constant (rtx op, enum machine_mode mode)
{ //cause of problem?
  unsigned step, copies;

  if (mode == VOIDmode)
    mode = GET_MODE (op);
  else if (mode != GET_MODE (op))
    return false;

  step = GET_MODE_NUNITS (mode) / 4;
    copies = 1;

  /* Try with a fxvsplath  */
  if (step == 1)
    copies <<= 1;
  else
    step >>= 1;

  if (vspltis_constant (op, step, copies))
    return true;

  /* Try with a fxvsplatb  */
  if (step == 1)
    copies <<= 1;
  else
    step >>= 1;

  if (vspltis_constant (op, step, copies))
    return true;

  return false;
}
\end{lstlisting}

This is the only time, we will use an AltiVec function (|vspltis_constant|) instead of defining a new function, as this function has not to be altered.
A similar function |gen_easy_s2pp_constant| can also be transfered as it is basically the same but generates RTL code that will create a constant vector operand from a different operand.

As all registers are now fully implemented, we have to take care of conflicts with FPRs.
s2pp registers and FPRs share the same indexes and since they are not fixed could be identified as FPRs.
For this reason we must scan the source files for uses of |FP_REGNO_P(N)| and add an exception with |&& !TARGET_S2PP| when it is necessary.
This is especially the case when dealing with hard registers and having the compiler emit register moves.

\section{Reload}
As hinted in section \ref{sec:GCC}, |reload| is a deprecated process in GCC that mainly performs register allocation.
Obviously we need to add special handling for vector registers to |reload| because because register allocation is an important part of the compilation process.
Thus we must add support for |S2PP_REGS|.

As |reload| is capable of moving the contents of registers, it must be specified that s2pp registers are not compatible with GPRs or any other registers.
It is also important to implement that memory instructions take two GPRs as registers.
\begin{lstlisting}
static reg_class_t
rs6000_secondary_reload (bool in_p,
                rtx x,
                reg_class_t rclass_i,
                enum machine_mode mode,
                secondary_reload_info *sri)
{...
  /* Handle vector moves with reload helper functions.  */
  if (ret == ALL_REGS && icode != CODE_FOR_nothing)
    {...
      if (GET_CODE (x) == MEM)
      {...
        if (rclass == GENERAL_REGS || rclass == BASE_REGS)
          {...
            /* Loads to and stores from vector registers can only do reg+reg
            addressing.  Altivec registers can also do (reg+reg)&(-16).  Allow
            scalar modes loading up the traditional floating point registers
            to use offset addresses.  */
            else if (rclass == VSX_REGS || rclass == ALTIVEC_REGS
                     || rclass == FLOAT_REGS || rclass == NO_REGS
                     || rclass == S2PP_REGS)
              {...
              }}}}}
...
\end{lstlisting}

Because registers are quite different in their specifications and reload could possibly ask for any combination of source/destination register we restrict s2pp register moves to other s2pp registers or memory.
This creates the need for checking the register class of an RTL expression and eventually correcting the register class.
\begin{lstlisting}
static enum reg_class
rs6000_preferred_reload_class (rtx x, enum reg_class rclass)
{...
  if ((rclass == S2PP_REGS)
      && VECTOR_UNIT_S2PP_P (mode)
      && easy_vector_constant (x, mode)){
    return rclass;
  }
}
...
static enum reg_class
rs6000_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,
                   rtx in)
{...
  if ((regno == -1 || S2PP_REGNO_P (regno))
      && rclass == S2PP_REGS)
    return NO_REGS;
...
}
...
\end{lstlisting}

As |reload| does not initially support the addressing mode which AltiVec and s2pp both use, indirect addresses for s2pp must be handled the same way as for AltiVec.
\begin{lstlisting}

void
rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)
{...
  switch (rclass)
    {...
    case S2PP_REGS:
    ...
    }
}
\end{lstlisting}

At last we also need to validate the mode which is used.
\begin{lstlisting}
static bool
rs6000_cannot_change_mode_class (enum machine_mode from,
                 enum machine_mode to,
                 enum reg_class rclass)
{
  if (TARGET_S2PP && rclass == S2PP_REGS
    && (S2PP_VECTOR_MODE (from) + S2PP_VECTOR_MODE (to)) == 1)
   return true;
  ...
}
\end{lstlisting}

\section{Built-ins, Insns and Machine Instructions}
\label{sec:builtins}
Basically the back-end is now capable of handling s2pp vector instructions.
The only thing that is left to do, is specifying machine instructions that move registers or access memory.
For this reason we add a machine description file |s2pp.md| to the back-end which will contain all available vector instructions.

We must index this new file in |rs6000.md| and |t-rs6000|.
\begin{lstlisting}
...
$(srcdir)/config/rs6000/s2pp.md
$
...
\end{lstlisting}
\begin{lstlisting}
...
(include "s2pp.md")
...
\end{lstlisting}

The most important insn is |*s2pp_mov<mode>|.
It is generally used by |emit_move_insn| to allocate registers and memory.
\begin{lstlisting}
(define_insn "*s2pp_mov<mode>"
  [(set (match_operand:FXVI 0 "nonimmediate_operand" "=Z,kv,kv,*Y,*r,*r,kv,kv")
   (match_operand:FXVI 1 "input_operand" "kv,Z,kv,r,Y,r,j,W"))]
  "VECTOR_MEM_S2PP_P (<MODE>mode)
   && (register_operand (operands[0], <MODE>mode) 
   || register_operand (operands[1], <MODE>mode))"
  { 
   switch (which_alternative)
    {
    case 0: return "fxvstax %1,%y0";
    case 1: return "fxvlax %0,%y1";
    case 2: return "fxvsel %0,%1,%1";
    case 3: return "#";
    case 4: return "#";
    case 5: return "#";
    case 6: return "fxvsel %0,0,0";
    case 7: return output_vec_const_move (operands);
    default: gcc_unreachable ();
    }
  } 
  [(set_attr "type" "vecstore,vecload,vecsimple,store,load,*,vecsimple,*")])
\end{lstlisting}

We explained the basics of insn definition earlier in section \ref{sec:defineinsn} thus we will only explain specific for this insn.
The name is proceeded by an asterisk that renders the name not accessible directly because this insn shall only be referred to by the RTL sequence that follows.
Names starting with an asterisk are in general equal to no name.

The RTL template is fairly simple and states that operand |0| is set by operand |1|.
Still, this insn applies for a number of cases which are specified by its constraints.
The constraints of each operand build pairs.
The first pair for example (|Z| and |kv|) tells the compiler that memory, which is accessed by an indirect operand |Z|, will be set by the contents of a vector register |kv|.
Which machine instruction is used for each pair of constraints is stated in the output template by |switch(which_alternative)|.
The template can also be written in C.

Each case is indexed according to the list of constraints so we take a look at |case 0|, which is the first pair.
This alternative return a machine instruction for storing a vector in memory |fxvstax|.
The second operand of this instruction also contains a character besides its index which is an operand modifier \citep{GCCint:asm} that will cause the operand |0| to be split into an offset and an address in respective GPRs.

Other alternatives include instructions |fxvlax|, for loading a vector from memory, and |fxvsel|, for moving vector registers.
|case 6| moves the contents of vector register |0| (this register is all |0|s) and thereby nulls that register (|j| is the respective constraint for a zero vector).

Returning |#| as output template is equivalent to stating that there is no machine instruction which can perform the RTL template.
This causes the compiler to look for different RTL templates that have the same effect but also has a machine instruction.

This process is called \textbf{insn splitting} and can also be used for optimization.
A developer may define which RTL templates are equivalent by using |define_split| \citep{GCCint:definesplit}.

As there exist non-AltiVec-specific splits for cases 3 through 5 in AltiVec, we do not need to define splits ourself.

Insn splitting is quite common for GCC back-ends because defining insns with unspecific constraints and then splitting them allows for easier generation of code.
The back-end will then automatically search for code that fits the operands of the instruction.
The same applies for |*s2pp_mov| which can not be referenced by name, but by an RTL template of |mov| in |vector.md|.
Inorder to fulfill the condition, we add the |S2PP_VECTOR_MODE_P| to the insn.
\begin{lstlisting}
(define_expand "mov<mode>"
  [(set (match_operand:VEC_M 0 "nonimmediate_operand" "")
        (match_operand:VEC_M 1 "any_operand" ""))]
  "VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode) || VECTOR_MEM_S2PP_P (<MODE>mode)"
  {...})
\end{lstlisting}

|define_expand| is an \textbf{insn expansion} which is similar to insn splitting, but may combine several RTL templates and can not specify any machine instruction directly.
Usually this is used to compose built-ins from an instruction sequence \citep{GCCint:defineexpand}.

|define_insn_and_split| is a combination of insn definition and insn splitting and is also described in the GCC manual \citep{GCCint:definesplit}.

Besides |mov| there is number of insn expansions in |vector.md| that must also apply to s2pp.
\begin{lstlisting}
(define_expand "vector_load_<mode>"
  [(set (match_operand:VEC_M 0 "vfloat_operand" "")
        (match_operand:VEC_M 1 "memory_operand" ""))]
  "VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode) || VECTOR_MEM_S2PP_P (<MODE>mode)"
  "")

(define_expand "vector_store_<mode>"
  [(set (match_operand:VEC_M 0 "memory_operand" "")
        (match_operand:VEC_M 1 "vfloat_operand" ""))]
  "VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode) || VECTOR_MEM_S2PP_P (<MODE>mode)"
  "")

;; Splits if a GPR register was chosen for the move
(define_split
  [(set (match_operand:VEC_L 0 "nonimmediate_operand" "")
        (match_operand:VEC_L 1 "input_operand" ""))]
  "(VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)  || VECTOR_MEM_S2PP_P (<MODE>mode))
   && reload_completed
   && gpr_or_gpr_p (operands[0], operands[1])
   && !direct_move_p (operands[0], operands[1])
   && !quad_load_store_p (operands[0], operands[1])"
  [(pc)]
{
  rs6000_split_multireg_move (operands[0], operands[1]);
  DONE;
})
...

(define_expand "vector_s2pp_load_<mode>"
  [(set (match_operand:VEC_X 0 "vfloat_operand" "")
        (match_operand:VEC_X 1 "memory_operand" ""))]
  "VECTOR_MEM_S2PP_P (<MODE>mode)"
  "
{
  gcc_assert (VECTOR_MEM_S2PP_P (<MODE>mode));
}")

(define_expand "vector_s2pp_store_<mode>"
  [(set (match_operand:VEC_X 0 "memory_operand" "")
        (match_operand:VEC_X 1 "vfloat_operand" ""))]
  "VECTOR_MEM_S2PP_P (<MODE>mode)"
  "
{
  gcc_assert (VECTOR_MEM_S2PP_P (<MODE>mode));
}")
...
(define_insn_and_split "*vec_reload_and_plus_<mptrsize>"
  [(set (match_operand:P 0 "gpc_reg_operand" "=b")
        (and:P (plus:P (match_operand:P 1 "gpc_reg_operand" "r")
                       (match_operand:P 2 "reg_or_cint_operand" "rI"))
               (const_int -16)))]
  "(TARGET_ALTIVEC || TARGET_VSX || TARGET_S2PP) && (reload_in_progress || reload_completed)"
  "#"
  "&& reload_completed"
  [(set (match_dup 0)
        (plus:P (match_dup 1)
                (match_dup 2)))
        (parallel [(set (match_dup 0)
                        (and:P (match_dup 0)
                               (const_int -16)))
                   (clobber:CC (scratch:CC))])])
...
(define_insn_and_split "*vec_reload_and_reg_<mptrsize>"
  [(set (match_operand:P 0 "gpc_reg_operand" "=b")
        (and:P (match_operand:P 1 "gpc_reg_operand" "r")
               (const_int -16)))]
  "(TARGET_ALTIVEC || TARGET_VSX || TARGET_S2PP) && (reload_in_progress || reload_completed)"
  "#"
  "&& reload_completed"
  [(parallel [(set (match_dup 0)
                   (and:P (match_dup 1)
                          (const_int -16)))
              (clobber:CC (scratch:CC))])])
...
(define_expand "add<mode>3"
  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
        (plus:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
                    (match_operand:VEC_F 2 "vfloat_operand" "")))]
  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode) || VECTOR_UNIT_S2PP_P (<MODE>mode)"
  "")

(define_expand "sub<mode>3"
  [(set (match_operand:VEC_F 0 "vfloat_operand" "")
        (minus:VEC_F (match_operand:VEC_F 1 "vfloat_operand" "")
                     (match_operand:VEC_F 2 "vfloat_operand" "")))]
  "VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode) || VECTOR_UNIT_S2PP_P (<MODE>mode)"
  "")
...
}])))]]}}]}]} !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! edit this away, included for spellchecking, some bracked not escaped
\end{lstlisting}

Before we can continue with other insns, we shall go back to |*s2pp_mov| and take a look at |case 7| which applies for constant vectors.

Constant vectors have a constant value that are known at compile time.
GCC will look for such vectors and check if these vectors can be splatted.
This is mainly used by AltiVec, which offers a special splat instruction that takes a constant immediate value as operand.
Splatting an immediate value saves a GPR and thus boosts performance.
Still, we keep this function, since we can achieve a similar effect for constant zero vectors by moving the zero register.
To distinguish between cases where this applies, we use the function |output_vec_const_move()| in|rs6000.c| which is also used by AltiVec.
Only if the vector is a zero vector, this functions returns a machine instruction, otherwise it will return |#|.
\begin{lstlisting}
const char * /*p_o_i*/
output_vec_const_move (rtx *operands)
{...
  if (TARGET_S2PP)
  {
    rtx splat_vec;
    if (zero_constant (vec, mode))
  return "fxvsel %0,0,0,0";

    splat_vec = gen_easy_s2pp_constant (vec);
    gcc_assert (GET_CODE (splat_vec) == VEC_DUPLICATE);
    operands[1] = XEXP (splat_vec, 0);
    if (!EASY_VECTOR_15 (INTVAL (operands[1]))){
  return "#";
    }
    mode = GET_MODE (splat_vec);
    if (mode == V8HImode){
  return "#";
    }
    else if (mode == V16QImode){
  return "#";
    }
    else
  gcc_unreachable ();
  }
\end{lstlisting}

Since we are now missing an instruction to use this split we will define a split ourselves which converts the immediate splat into a normal splat:
\begin{lstlisting}
(define_split
  [(set (match_operand:FXVI 0 "s2pp_register_operand" "")
   (match_operand:FXVI 1 "easy_vector_constant" ""))]
  "TARGET_S2PP && can_create_pseudo_p()"
  [(set (match_dup 2) (match_dup 3))
   (set (match_dup 0) (unspec:FXVI [(match_dup 2)] UNSPEC_FXVSPLAT))]
  "{
   operands[2] = gen_reg_rtx (SImode);
   operands[3] = CONST_VECTOR_ELT(operands[1], 1);
   }")
...
(define_insn "*s2pp_fxvsplat<FXVI_char>"
  [(set (match_operand:FXVI 0 "register_operand" "=kv")
   (unspec:FXVI
         [(match_operand:SI 1 "register_operand" "r")] UNSPEC_FXVSPLAT))]
  "TARGET_S2PP"
  "fxvsplat<FXVI_char> %0,%1"
  [(set_attr "type" "vecperm")])
\end{lstlisting}

We split the upper RTL template, which moves a constant vector to a vector register into the bottom RTL template, which inserts an intermediate step.
|match_dup n| means that the operand should match the operand with the same index, that is specified somewhere else.
For this reason are operands 2 and 3 specified in the following C template, which also converts operand 1 into a single integer element because all values are the same.
The second RTL template uses the newly created integer and moves it to a GPR, which is then splatted into a vector register.

An |unspec| operator together with |UNSPEC_...| tells the compiler that the operation is not specified but has a name to distinguish it from other unspecified operations.
\\
\\
Now that memory insns for s2pp exist, we can also implement them in |rs6000.c| as well.
In |rs6000_init_hard_regno_mode_ok| we must assign code for store and load instructions to supported modes in case the target flag is set.
As this is also done for AltiVec, we simply differentiate between those option flags.

By now the compiler would already support |asm| usage as shown in \ref{section:asm}.

This also completes the prerequisites for intrinsic functions of \textbf{built-ins}.
The different steps of adding built-ins were also described in a previous internship report \citep{heimbrecht_2017internship}.
Therefore we will only describe this briefly and refer to the report at times.

First we start defining insns for each vector instruction that is listed in the nux user guide \citep{nuxmanual}.
In order to allow access to the synram we implement insns that work similar to |fxvstax| and |fxvlax| and are called |fxvoutx| and |fxvinx|.
\begin{lstlisting}
;;store
(define_insn "s2pp_fxvstax<fxvstax_char><mode>"
  [(parallel
    [(set (match_operand:FXVI 0 "memory_operand" "=Z")
          (match_operand:FXVI 1 "register_operand" "kv"))
     (unspec [(const_int 0)] FXVSTAX)])]
  "TARGET_S2PP"
  "fxvstax %1,%y0,<fxvstax_int>"
  [(set_attr "type" "vecstore")])

;;load
(define_insn "s2pp_fxvlax<fxvlax_char><mode>"
  [(parallel
    [(set (match_operand:FXVI 0 "register_operand" "=kv")
          (match_operand:FXVI 1 "memory_operand" "Z"))
     (unspec [(const_int 0)] FXVLAX)])]
  "TARGET_S2PP"
  "fxvlax %0,%y1,<fxvlax_int>"
  [(set_attr "type" "vecload")])

;;synram
(define_insn "s2pp_fxvoutx<fxvoutx_char><mode>"
  [(parallel
    [(set (match_operand:FXVI 0 "memory_operand" "=Z")
          (match_operand:FXVI 1 "register_operand" "kv"))
     (unspec [(const_int 0)] FXVOUTX)])]
  "TARGET_S2PP"
  "fxvoutx %1,%y0,<fxvoutx_int>"
  [(set_attr "type" "vecstore")])

(define_insn "s2pp_fxvinx<fxvinx_char><mode>"
  [(parallel
    [(set (match_operand:FXVI 0 "register_operand" "=kv")
          (match_operand:FXVI 1 "memory_operand" "Z"))
     (unspec [(const_int 0)] FXVINX)])]
  "TARGET_S2PP"
  "fxvinx %0,%y1,<fxvinx_int>"
  [(set_attr "type" "vecload")])
\end{lstlisting}
All of these insns exist with different conditionals and are named accordingly because load and store insns are hard to implement with an additional argument that is the conditional.
\\
\\
Simple arithmetic instructions exist in multiple versions that either support conditional execution or do not.

Due to an issue with nux regarding conditionals and arithmetic instructions, there exist two different ways of how conditionals are realized
As tests revealed, the conditional execution of arithmetic instructions perform unexpectedly in case a condition does not apply.
In this case, the result of a previous instruction is written to the return operand.
Normally the operation should leave the contents of the operand untouched instead.
For this reason we implement a workaround through insn splitting, that utilizes |fxvselect| and its conditional execution, as this instruction does work as intended.
This was shown by another series of tests.
Still, we should offer arithmetic operations without splits as this saves a clock cycle in comparison to having an additional |fxvselect|.

As of now, this was only done for simple arithmetic operations, |fxvadd...|, |fxvsub...| and |fxvmul...|.
There also exist more complex operations that make use of the accumulator, which should not be used with conditionals as further testing is imminent and it is not clear whether those conditionals would work.
Additionally would an extra instruction render the advantages of an accumulator meaningless.
Nonetheless were accumulator instructions implemented together with a conditional argument which will allow for easier testing later on.
Also does the additional operand not influence the performance of the instruction in a bad manner when set to |0|.

We will refer back to this when discussing the results.
\\
\\
Since this completes the insns we can go on and create built-ins for these in |rs6000-builtins.def|.
First though we add macros that simplify adding intrinsics.
The exact definition of those macros is described for AltiVec built-ins in the internship report \citep{heimbrecht_2017internship} and we can easily transfer those for s2pp by adding the |RS6000_BTM_S2PP| built-in mask in |rs6000.h|.
\begin{lstlisting}
#define RS6000_BTM_S2PP     MASK_S2PP   /* s2pp-mark/s2pp vectors.  */

#define RS6000_BTM_COMMON   (RS6000_BTM_ALTIVEC         \
...
                 | RS6000_BTM_S2PP)
\end{lstlisting}

We then use those new s2pp built-in macros to create built-in definitions for each insn and also each mode (halfword or byte).
Most built-ins follow the scheme of a normal function that has a result and a certain number of arguments.
But there is a number of insns that do not produce an output as they set the accumulator or the conditional register.
These instructions need special handling and thus are defined as special built-ins.

Besides defining built-ins we also define overloads.
These are used to differ intrinsics through arguments types, simplify using them easier and prevent false usage.
Overloads are also further explained in the intership report\citep{heimbrecht_2017internship}.

To make overloads usable one must link them to existing buili-ns as overloads are not directly connected to insns.
This is done through structures that combine the built-in and overload names with a return type and up to three arguments.

To use these structures, we will add a function to |rs6000-c.c| that resolves the overloaded built-ins and is again built upon an AltiVec function that does the very same.
These functions are |s2pp_build_resolved_builtin| and |s2pp_resolve_overloaded_builtin|

Which resolving function is used by the back-end, is decided in |rs6000.h|
\begin{lstlisting}
#define REGISTER_TARGET_PRAGMAS() do {              \
   c_register_pragma (0, "longcall", rs6000_pragma_longcall);    \
   targetm.target_option.pragma_parse = rs6000_pragma_target_parse; \
   if(OPTION_MASK_S2PP) \
     targetm.resolve_overloaded_builtin = s2pp_resolve_overloaded_builtin; \
   else \
     targetm.resolve_overloaded_builtin = altivec_resolve_overloaded_builtin; \
   rs6000_target_modify_macros_ptr = rs6000_target_modify_macros; \
} while (0)
\end{lstlisting}

Also we need functions in |rs6000.c| that handle built-ins in general.
A new function |s2pp_expand_builtin|, which is invoked by |rs6000_expand_builtin|, handles all special built-ins that belong to s2pp and picks expander functions according the built-in's name.
We therefore must create expander functions that take care of s2pp built-ins.

One group of built-ins are memory intrinsics that handle explicit memory addressing and synram intrinsicsi (|fxvinx|, |fxvoutx|).
Expanders are needed because of the special way memory is accessed through indirect register referencing.
Since AltiVec uses the same way of addressing we can reuse its implementation but use a different function names |s2pp_expand_stv_builtin| and |s2pp_expand_lv_builtin|.

Besides memory expander functions we add a new kind of expander function for s2pp.
These expect no kind of return operand since a great number of instructions do not return any values because they write the accumulator or the conditional register.
These functions are called |s2pp_expand_unaryx_builtin|, |s2pp_expand_binaryx_builtin| and |s2pp_expand_ternaryx_builtin| and are used in regard to the number of arguments in a built-in.
\begin{lstlisting}
static rtx
s2pp_expand_unaryx_builtin (enum insn_code icode, tree exp)
{
     tree arg0;
     rtx op0, pat;
     enum machine_mode mode0; //, tmode;
     arg0 = CALL_EXPR_ARG (exp, 0);
     op0 = expand_normal (arg0);
     mode0 = insn_data[icode].operand[0].mode;

     /* If we got invalid arguments bail out before generating bad rtl.  */
     if (arg0 == error_mark_node)
       return const0_rtx;

     if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))
       op0 = copy_to_mode_reg (mode0, op0);

     pat = GEN_FCN (icode) (op0);
     if (pat)
       emit_insn (pat);
     return NULL_RTX;
}
\end{lstlisting}

As we are already handling special built-ins we need to define those built-ins in |rs6000.c| as well.
|s2pp_init_bultins| takes care of this, as it is a series of |define_builtin| functions which must be written explicitly.

Besides built-ins that are connected to vector instructions, it is also possible to create intrinsics, that rely solely on GPRs.
|vec_ext|, |vec_init| and |vec_promote| are built-ins, which are compiler-constructed sequences of machine instructions that mainly use memory.
These functions are identical to AltiVec's implementation since they do not need a vector extension.

Finally we conclude on built-ins by defining alternative names for built-in functions in |s2pp.h|.
A complete list of all intrinsic functions that the compiler supports at the time this thesis was written is available in the appendix \ref{appendix:builtinlist}.

\section{Prologue and Epilogue}
Another problem, that only emerges, when using many registers at the same time, is missing prologue and epilogue support.

There is an ending number of registers, which the compiler can use for saving values, and this number is also reduced by the amount of fixed registers
Thus the compiler occasionally must store values in memory before calling a function that needs some of the available registers by calling a so called \textbf{prologue} \citep{GCCint:funcentry}.
The compiler then restores the registers after the function has finished through an \textbf{epilogue}.

Before the compiler can save registers, it must check which registers need to be saved.
This is done by |seve_reg_p()|.
In |rs6000_emit_prologue| the compiler checks each register that exists and saves them according to this function.
Since the compilers checks register numbers instead of types, we need to alter the case for FPRs and add a target flag:
\begin{lstlisting}
...
  if (!WORLD_SAVE_P (info) && (strategy & SAVE_INLINE_FPRS))
    {
      int i;
      if (!TARGET_S2PP){
        for (i = 0; i < 64 - info->first_fp_reg_save; i++)
          ...
      }
      else{
        for (i = 0; info->first_s2pp_reg_save + i <= LAST_S2PP_REGNO; i++)
          if (save_reg_p (info->first_s2pp_reg_save + i)){

            int offset = info->s2pp_save_offset + frame_off + 16 * i;
            rtx savereg = gen_rtx_REG (V8HImode, i+info->first_s2pp_reg_save);
            rtx areg = gen_rtx_REG (Pmode, 0);
            emit_move_insn (areg, GEN_INT (offset));
            rtx mem = gen_frame_mem (V8HImode,gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));
            insn = emit_move_insn (mem, savereg);
            rs6000_frame_related (insn, frame_reg_rtx, sp_off-frame_off, areg,
            GEN_INT(offset), NULL_RTX);
        }
      }
      ...
    }
...
\end{lstlisting}
An |rtx|, which was a type often used in the previous listing, is short for RTL expression and can be used by |insn|s as an argument.
RTL expressions can also contain information on how the operand is to be constructed as this allows chaining of operations.

If register needs to be saved, the compiler computes an offset, that takes the current frame offset and adds 16 bytes(s2pp register size) for every register.
|savereg| and |areg| are two kinds of registers that will later serve as operands for a memory instruction.
|savereg| is the vector register we want to save and |areg| will be the GPR operand that holds an offset\reference{fxvstax and fxvlax}
|emit_move_insn| creates IR that stores the offset in |areg|.
Now we can create a complete memory operand |mem| that takes |offset| in |areg| and |frame_reg_rtx|, which is the register holding the frame pointer, and combines them to a single operand.
As both, register and memory, are specified, the compiler can emit a move insn that stores |savereg| to |mem|.
Finally |rs6000_frame_related| handles the insn which was just created and performs additional customizations which are needed as the IR belongs to a function call.

After the prologue has finished, the function is compiled.
Next, |rs6000_emit_epilogue| is called and works similar to prologue but restores the registers from memory.
This function can not work on its but needs other functions that set parameters and prepare statements as well.
\begin{lstlisting}%[caption=Supportive functions and variables for prologue and epilogue]
typedef struct rs6000_stack {
    ...
    int first_s2pp_reg_save;
    ...
    int s2pp_save_offset;
    ...
    int s2pp_size;
    ...}
...
int
direct_return (void)
{
  if (reload_completed)
    {
      rs6000_stack_t *info = rs6000_stack_info ();

      if (info->first_gp_reg_save == 32
      ...
      && info->first_s2pp_reg_save == LAST_S2PP_REGNO + 1
      ...)
    return 1;
    }

  return 0;
}
...

static int
first_s2pp_reg_to_save (void)
{
  int i;

  /* Find lowest numbered live register.  */
  for (i = FIRST_SAVED_S2PP_REGNO; i <= LAST_S2PP_REGNO; ++i)
    if (save_reg_p (i))
      break;

  return i;
}
...
static rs6000_stack_t *
rs6000_stack_info (void)
{...
    info_ptr->first_s2pp_reg_save = first_s2pp_reg_to_save ();
    info_ptr->s2pp_size = 16 * (LAST_S2PP_REGNO + 1
                    - info_ptr->first_s2pp_reg_save);
...
}
\end{lstlisting}


\add{
stack boundary -> put this together
frame offsetr
stackoffset
}
