\chapter{Extending the GCC Back-End}
\label{chapter:extbackend}
Since we now are familiar with the basics of processors, the PPU, compilers and GCC we can put this knowledge to use and start extending the GCC back-end.
There es a set of files we will systematically edit and keep referencing to as they are important parts of the rs6000 back-end and were changed in the process of extending the back-end. 
\begin{description}
    \item[rs6000.md] this is the machine description of the back-end in general and contains the insn definitions for all scalar functions
    \item[rs6000.h] is a header file which contains all macros and declaration of registers
    \item[rs6000.c] is the source file which implements all functions that are needed for generation of the back-end and other accompanying functions
    \item[rs6000.opt] lists the options and flags which can be set for the target
    \item[rs6000-builtins.def] contains the definitions of built-ins/intrinsics
    \item[rs6000-cpus.def] lists subtargets that belong to the rs6000 family
    \item[rs6000-c.c] links built-ins to overloaded built-ins
    \item[rs6000-opts.h] contains a set of enumerations that represent option values for the back-end
    \item[rs6000-protos.h] makes functions in |rs6000.c| globally available
    \item[rs6000-tables.opt] lists string/int equivalent to an enumeration which lists CPU types
    \item[driver-rs6000.c] mostly a collection of driver details for different targets
    \item[ppc-asm.h] sets macros for the use of |asm|
    \item[s2pp.md] is a new file that is the machine description of the nux' VE and contains insn definitions for the VE
    \item[s2pp.h] is the header file that defines aliases for built-ins
    \item[constraints.md] contains definitions of the constraints that are used
    \item[predicates.md] contains definitions of the predicates that are used
    \item[vector.md] declares insn definitions that apply to vector types in general
    \item[sysv4.h] initializes a variety of option flags an sets default values
    \item[t-fprules] sets soft-float as default for certain targets
\end{description}

Before we start it should be emphasized where inspiration was taken from in order to take the right steps when extending the back-end.
There exists no specific documentation on the rs6000 back-end whatsoever and most information on the ways it works is available through comments in code only.
There is however an existing vector extension which is included in the back-end and is quite similar to the vector extension we want to add.
The existing vector extension is the AltiVec Vector extension, we described earlier in this thesis.
The source code thus often shows strong similarities between AltiVec and s2pp functions.
Still handling AltiVec and s2pp vectors is separated throughout the back-end since mixing these and reusing function can both get messy and dangerous since at times one vector extension must be distinguished from another.
Also there do exist enough differences between these two VEs that combining functions and having separate ones would not make a big difference in the end.

We will start with adding the |nux| processor to the list of targets and also want to include mandatory flags with this.
Ideally the user only has to add the option flag |-mcpu=nux| when compiling in order to produce machine code for the nux.
the flags which have to be set when using the nux are:
\begin{description}
        \lstitem{-msdata=none} disables the use of a "small data section" which is like a data section but has a register constantly referring to it and thus has faster access than the normal data section. Globals, statics and small variables that are often used are preferably stored there.
        \lstitem{-mstrict-align} aligns all variable in memory which means that a variable always starts at a memory address without offset. Every variable requests at least 1 byte of memory when strictly aligned
        \lstitem{-msoft-float} tells the compiler that there is no FPU and all floating point operations have to simulated by software.
        \lstitem{-mno-relocatable} states that the program code has a fixed memory address that may not be altered.
\end{description}

To do so we first create the flag |-ms2pp| along with an option mask.
This should activate the vector extension and everything associated with it.
In rs6000.opt and we simply need to add the lines:
\begin{lstlisting}
ms2pp
Target Report Mask(S2PP) Var(rs6000_isa_flags)
Use s2pp instructions
\end{lstlisting}
|ms2pp| is the name of the target flag and the next lines defines which macros shall be defined.
|Target| means that the option is target specific, |Report| means that the option is to be printed when |-fverbose-asm| is activated.
|Mask(S2PP)| initializes a bitmask that is available through |OPTION_MASK_S2PP| which is attached to |rs6000_isa_flags| specified by |Var| and in parallel specifies a macro |TARGET_S2PP| that is set to |1|. \cite{GCCint:options}
When we are finished with this we need to specify |#define MASK_S2PP OPTION_MASK_S2PP| which is done in |rs6000.h| as |MASK_| is the standard.

Now we add the processor type which uses this flag as a standard.
There exist several lists that contain available targets and we need to add the nux to these.
First we add the |asm| flag that tells the assembler which system architecture is used.
As the nux is based on Power7 and the VE does not influence |asm| for the GPP we want nux to behave like Power7.
To do so we add |%{mcpu=nux: %(asm_cpu_power7)}| to |ASM_CPU_SPEC| and simultaneously add |{ "nux",  "%(asm_cpu_power7)" }| to |static const struct asm_name asm_names[]| as these arrays must be kept identical.
This will induce the assembler flag to be set to |-mpower7|.

Now we want to achieve something similar for the preceding phases of the back-end as as the description of flags above is mandatory to running nux.
First we will create an entry in |rs6000-cpus.def| which sets the flags accordingly:
\begin{lstlisting}
RS6000_CPU ("nux", PROCESSOR_POWER7, MASK_SOFT_FLOAT | MASK_S2PP | MASK_STRICT_ALIGN | !MASK_RELOCATABLE)
\end{lstlisting}
will define the processor as a Power7 type and add the masks for soft-float, strict-align and no-relocatable(negative of relocatable) as well as the new s2pp mask.
Setting a mask is the low-level equivalent to adding a flag as every flag induces a mask, which we saw earlier, and thus this will fit our cause.
Calling |RS6000_CPU| will basically generate an entry to the enumeration |rs6000_cpu_opt_value| which must be linked to a string following |-mcpu=|.
This is done in |rs6000-tables.opt| where a string, in our case |nux|, is associated with the |n|-1-th call of |RS6000_CPU| through:
\begin{lstlisting}
EnumValue
Enum(rs6000_cpu_opt_value) String(nux) Value(n)
\end{lstlisting}
One must basically count the calls of |RS6000_CPU| to get n.

As we are still missing the |-msdata=none| flag, we will take care of this now.
Because |-msdata| is not an ordinary target flag, we need to initialize it differently.
Depending on the string following |-msdata=| the back-end decides which mask is referred to when calling |rs6000_sdata|.
This is decided in |sysv4.h| through comparing with different valid strings.
Since we were only able to set option masks before we need a little work-around here that helps us setting the value of |rs6000_sdata|.
If |-msdata| was not defined as it is the case with |-mcpu=nux| the compiler will check through |else if|s what to do for |rs6000_sdata|.
We simply add one such check in front of all other |else if|s and check for all the target flags that |-mcpu=nux| sets.
Hence the target options will also set |rs6000_sdata| as we wish which is to |SDATA_NONE|.
Although there exists a case for which this condition applies even if |nux| is not set as target and that is when all target flags are set by hand.
Still if one chooses an explicit value for |-msdata| the option does not apply and the explicit value is taken into account.
This is somewhat not the ideal way of solving this problem but fulfills its purpose with as few side effects as possible.

Already this would allow us to use |-mcpu=nux| as target flag and |-ms2pp| as option flag.
But since the flags we used are mandatory to the s2pp extension we also want to check these flags before starting compilation.
First though we must create macros for each flag which the back-end notices.
This is done in |rs6000-c.c| in function |rs6000_target_modify_macros| where we can define macros depending on target flags.
\begin{lstlisting}
  if ((flags & OPTION_MASK_S2PP) != 0)
    rs6000_define_or_undefine_macro (define_p, "__S2PP__");
\end{lstlisting}

If |flags| and the respective option mask are set, |rs6000_define_or_undefine_macro| will define a macro which is the second argument if a macro is defined or undefined depends on the boolean |define_p| but the back-end takes care of this on its own.
We do this for all flags we are interested in.
Now we will use these new macros to check if the flags are set.
Before we do this though we create a new file that is |s2pp,h| and index this in |gcc/config.gcc| under |extra_headers| at |powerpc*-*-*|.
We do this so GCC actually invokes the header file as it is not referenced elsewhere.
After we added the usual conditional header macro to the file we add the first lines of code which are:
\begin{lstlisting}
#if !defined(__S2PP__)
#error Use the "-ms2pp" flag to enable s2pp support
#endif
\end{lstlisting}\unsure{do more often like this: one example for repetitive use}
Hence if |__S2PP__| was not defined because the target flag was not set, the compiler will emit an error that tells the user to set the target flag.
This is done for all macros that we set above so to prohibit false use of nux.
But we will also put in a second measure to prevent false use of |floats| by adding |nux| to the list of soft-float CPUs in |t-fprules|.

Since the preliminary requirements for the activation of the VE are now met, we start adding the remaining fundamental macros and also add a |vector| attribute that the user may use later.
First we add a new Vector type which we will need from time to time.
We call it |VECTOR_S2PP| and add it to the enumeration |rs6000_vector| in |rs6000-opts.h|.
To put this to use we will create macros in |rs6000.h| which test vector modes if they correspond to the available modes in s2pp.
Hence we add many macros of this form which take and argument and compare it to a valid s2pp type/value.
\begin{lstlisting}
#define VECTOR_UNIT_S2PP_P(MODE)            \
    (rs6000_vector_unit[(MODE)] == VECTOR_S2PP)
\end{lstlisting}
checks the mode's associated vector unit and compares this to |VECTOR_S2PP|.
We also add checking for specific vector modes which shall be chosen carefully.
The hardware only supports two types of vectors which are vectors with byte elements and vectors with halfword elements.
Thus the respective modes are |V16QImode| and |V8HImode| which can be checked by |S2PP_VECTOR_MODE(MODE)|.

We also need to find conditions which should apply to |TARGET_S2PP| as they already to for |TARGET_ALTIVEC|.
Luckily there exist only two options which prohibit misalignment of vectors and control the right alignment.
Besides that only a few functions which we will discuss later need |TARGET_S2PP| to be called.
Other options such a permutation of vectors are not supported by s2pp or need a different implementation all together.
The same procedure must be applied for checking vector modes by checking using |VECTOR_UNIT_S2PP_P| and similar macros.
These are mainly used in |rs6000.c| when addressing vectors in memory through registers as operands.
Similar but more complex implementations will build the rest of this chapter and therefore we will not go into detail for every macro like
\begin{lstlisting}
#define UNITS_PER_S2PP_WORD 16
\end{lstlisting} 
that is used.

Now that we have added the s2pp vector we identify it with the available modes which is done in |rs6000.c|.
In |rs6000_init_hard_regno_mode_ok| we check for the s2pp target flag and assign |VECTOR_S2PP| to the modes |V16QImode| and |V8HImode|.
Also we add the modes for preferred modes when vectorizing a value in |rs6000_preferred_simd_mode| and decline the usage of offset addressing for these modes in |reg_offset_addressing_ok_p|.

We will now define an attribute to use these vector modes.
Thankfully GCC already supports a vector attribute which is also used by AltiVec.
Thus we can add s2pp to the |rs6000_attribute_table| and |rs6000_opt_mask[]| array with the same values as for AltiVec but changing the keyword.
This forces us to add the function |rs6000_handle_s2pp_attribute| which is the same as the AltiVec version but stripped off some vector modes which are not supported.
We could use those attributes already but they would come in quite unhandy thus we will define an alias to represent the new attribute in |rs6000-c.c|:
\begin{lstlisting}
builtin_define ("__vector=__attribute__((s2pp(vector__)))");
\end{lstlisting}
This is the same for AltiVec and copies the usage of vectors in AltiVec.
As does our addition of an s2pp case in |rs6000_attribute_takes_identifier_p| to complete the attribute.

\section{Registers}
\label{section:register}
Now we start adding the registers of s2pp to the back-end.
There are three types of registers we need to add:
\begin{description}
    \item[32 vector registers] these are normal registers that hold vector values
    \item[1 accumulator] which is used for chaining arithmetic instructions and cannot be accessed directly
    \item[1 conditional register] which holds conditional bits and also cannot be accessed directly
\end{description}
Registers are declared in |rs6000.md| thus we will do so as well.
\begin{lstlisting}
...
(S2PP_COND_REGNO     32)
(FIRST_S2PP_REGNO    33)
(LAST_S2PP_REGNO     63)
(S2PP_ACC_REGNO      64)
...
\end{lstlisting}\todo{necessary?}
is added to the Definition of constants at the beginning of |rs6000.md|, where we give a range for the vector registers and after which we pick specific register numbers for the special vector registers.
The number of these special vector registers does not matter though as we only need a number which no other registers that is used by nux refers to.
There is a reason why we put the conditional register at 32 and only provide 31 vector registers:
As the GPRs need the first 32 registers numbers (0-31) and there is never an FPU in nux, we want to use the 32 registers normally reserved to FPRs.
However during the first tests of nux with its vector extension it became apparent that a reserved register with all bits set to |0| would come in handy at times.
For one reason nux' instruction set does not include logical instructions especially no exclusive or (|xor|) function which is the standard way of having a registers set to all |0|s (since |xor|ing a value/register with the same value/register will always return |0|) and also it does not provide an |or| function which is the standard way of moving registers around as it was shown in section \ref{section:asm}\todo{check this refernce}.
This led to the problem of ``nulling'' a register at times it was needed.
Therefore the first register was left out and filled with zeros in order to be able to simply move/copy this register to a different one that needed to be nulled.
Moving around registers was also realized differently than for normal architectures as |fxvselect| was used instead of |or| where the first operand is the destination while second and third operand are the source.
The last operand, which is the conditional one, is set to |0| or left out as this substitutes the contents of the first operand always with that of the second operand.
Now as this renders a simple work-around, substituting |xor| is more difficult and although there are ways of utilizing |fxvselect| to copy its functionality \todo{explain this later} which we will care about later on.
Particularly as |fxvselect| is the fast vector instruction as it takes only one cycle to complete and all other arithmetic instruction most likely take significantly more cycles.
For this reason nulling a register by subtracting it by itself and storing the result in the same register would take more time hence would cost performance.
Therefore the trade-off of having one less register at hand instead of wasting clock cycles continuously is adequate.
Therefore since we do not want to reference the first vector register and cannot access the condition register by reference we simply reuse the register number for this cause.
Unfortunately we do not have a second dispensable register of that kind and thus need to find a different index for the accumulator - though the same non-availability as for the conditional register applies.
Luckily the POWER architecture does not reference the register index 64 for some reason so we can use that index without causing any conflict.

Now since we declared the vector registers' indexes we will create fitting macros as well.
We need to decide on which registers shall serve which purpose.
In this regard we shall also emphasize a little on fixed, call-used and saved registers.
Fixed registers serve purpose that does not allow them to hold any other values at any time at all.
Call-used registers are registers that are also not available for general register allocation as they are used for function calls and returning values.
Only saved registers can be used for general register allocation as these may hold values over function calls such as variables that are often used throughout the program.
This is done through macros which decide on the first saved register (in our case the 20th vector register) and list registers available for function arguments (a set of |S2PP_ARG_| macros).
Also |FUNCTION_..._REGNO_P(N)| tells us if register |N| is used for function arguments in general.
This number of course can be optimized depending on the applications for the nux and also the style of programming but we keep the same number of registers saved as AltiVec and the FPU do.

Of course we need to go through the source files to find any use of those macros and add the new s2pp macros.
We will not mention this every time as this is a standard procedure.

Now we need to get even more specific on the way the registers are organized.
First we add |S2PP_REGS|, |S2PP_C_REG|, and |S2PP_ACC_REG| to the enumeration |reg_class| and define the identical names in |REG_CLASS_NAMES|.
Then we need to specify the contents of our new register classes in |REG_CLASS_CONTENTS|.
\begin{lstlisting}
/* S2PP_REGS.  */                                                 \
{ 0x00000000, 0xfffffffe, 0x00000000, 0x00000000, 0x00000000 },   \
/* S2PP_C_REG.  */                                                \
{ 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },   \
/* FLOAT_REGS.  */                                                \
{ 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000 },   \
/* S2PP_ACC_REG.  */                                              \
{ 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000 },   \
\end{lstlisting}
Each hexnumber in these arrays can be viewed as a bit mask where the least significant bit is the first register, next higher order bit the second register and so on.
Each number is 32-bit and therefore equivalent to 32 registers.
The following numbers start where the previous one ended, therefore is the second number the bit mask for registers 32 through 63 (32 is the 33rd register).
Therefore does |0xfffffffe| mask all register except for number 32 which is covered by |0x00000001| and 64 is masked the same way.
One can see that the FPRs are masked completely as |FLOAT_REGS|.
The reason for this order is that subsequent entries must not me subsets of previous masks but may extend these.
Since we also included a register which was not used at all before we also have to change subsequent masks accordingly.

Now that we defined register classes we again add macros to compare these as we did before.
\begin{lstlisting}
#define S2PP_REG_CLASS_P(CLASS)         \
    ((CLASS) == S2PP_REGS)
...
\end{lstlisting}

Next we need to pick names for those new registers that we just defined.
These were chosen according to the constraints we will define next which are |kv| for normal vector registers, |kc| for the conditional register, |ka| for the accumulator.
Defining (in this case alternative) names for registers is also part of a macro |ADDTIONAL_REGISTER_NAMES| with elements that look like:
\begin{lstlisting}
  {"kc", 32}, {"kv0",  33}, {"kv1",  34}, {"kv2",  35},   \
  ...
\end{lstlisting}
The strings are the names for the registers and the integers are their indexes.

Now we also want to add the constraints which we just proposed.
we therefore go to |constraints.md| and add the following code for |kv|, |kc| and |ka|:
\begin{lstlisting}
(define_register_constraint "kv" "rs6000_constraints[RS6000_CONSTRAINT_kv]"
    "s2pp vector register")
\end{lstlisting}
where the first string is the register constraint's name and |rs6000_constraints[RS6000_CONSTRAINT_kv]| will be assigned a register name later on in |rs6000.c|,where it is also declared, which in this case is |S2PP_REGS| though this is only done if the target flag |-ms2pp| was set.
The last string is only for documentary purposes.\cite{GCCint:constraints}
We chose |k| as the first initial of s2pp registers because there are very few letters left which are not used as a constraint already and k is one of them which is at least somewhat associated with the processor (``nuks'').
The second character was chosen from the initial of the respective register type.

The next step which is necessary to make the registers widely accessible is adding them to |rs6000.c|.
For once we add the new registers to |rs6000_debug_reg_global| in order for them to be listed when printing out debug information.
This is done the same way AltiVec registers are implemented and fairly easy.
The same applies for pretty much all debugging support (THIS IS NOT gdb) therefore we do not mention additions to debugging, but in general these were done.
It is far more important to add the registers to |rs6000_init_hard_regno_mode_ok| which initializes global tables that are based on register size.
Basically every index in |rs6000_regno_regclass[]| is given a register class which corresponds to the register of that index and afterwards each register class is assigned a register type in |reg_class_to_reg_type[]|.
\begin{lstlisting}
for (r = 32+1; r < 64; ++r)
    rs6000_regno_regclass[r] = S2PP_REGS;
...
rs6000_regno_regclass[S2PP_COND_REGNO] = S2PP_C_REG;
rs6000_regno_regclass[S2PP_ACC_REGNO] = S2PP_ACC_REG;

reg_class_to_reg_type[(int)S2PP_REGS] = S2PP_REG_TYPE;
...
}
\end{lstlisting}

This is done only when |TARGET_S2PP| is true and substitutes the |FLOAT_REGS| at indexes 33 through 63 with |S2PP_REGS| and also adds the conditional and accumulator registers.
To complete the process the register classes are assigned a respective register type which was added to the enumeration |rs6000_reg_type| before that.
It is important to note that the s2pp normal register type was also added to the list of standard register types (again as a macro), as s2pp registers are meant to act like normal registers and also to the floating point/vector register types which is necessary as they are handled differently later in the source file.

Register can also be fixed (\reference{previous section}) according to compiler flags which is done in |rs6000_conditional_register_usage|.
E.g. when the flag for soft-float is set, the compiler calls all FPRs fixed (ergo not available), which is contrary to our plan of using these registers.
That is the reason why we add the alternative condition that the s2pp flag may not be set for this to happen.
Instead we fix the registers 32 and 64 which are the used otherwise (|kc| and |ka|).

Now that we fulfilled all measures of adding the registers to |rs6000.c| we need to add them to the list of possible |asm| operands in 
|ppx-asm.c| where a simple definition like |#define k0 1| is enough if this is done for each register name.
This tells the compiler to substitute |k0| for 1 as only pure integers are valid machine operands.

The last step to completing register usage for the back-end is adding fitting predicates in |predicates.md|.
We can copy these from the respective AltiVec predicates and change both the vector specific macros and the predicates' names.
The affected predicates are:
\begin{description}
        \lstitem{s2pp_register_operand} is a vector that is stored in a s2pp register
        \lstitem{easy_vector_constant} returns 1 if the operand is a constant vector and now also tests for s2pp vectors and calls a new function |easy_s2pp_constant|
        \lstitem{indexed_or_indirect_operand} applies for indexed or indirect operands (e.g. memory addresses in registers) and now supports the case of a s2pp vector operand as for AltiVec vectors
        \lstitem{s2pp_indexed_or_indirect_operand} is the same but only for s2pp vectors, not AltiVec
\end{description}
If one wants to add own predicates, GCC offers a manuals entry \cite{GCCint:predicates}.

The |easy_s2pp_constant| function checks if an operand is ``splittable'' which means that all elements are the same and thus can be generated through a split instruction.
To check this the operand is analyzed sequentially if either of the two available splats can synthesize the same operand.
This was also transferable from an AltiVec equivalent with the exception that one vector mode had to be removed.
prologue epilogue
Additionally the similar function |gen_easy_s2pp_constant| could also be transfered as it works the same way but generates RTL code that will create a constant vector operand from a different operand.

Now as we have completely added the new registers, we must take care of some consequences this caused.
Mainly our problem is that we reused the floating point registers and did not mark them as fixed \reference{earlier}.
For this reason we must scan the source files for |FP_REGNO_P(N)| and add an exception with |&& !TARGET_S2PP| when it is necessary.
This is especially the case when dealing with hard registers and having the compiler emit register moves.

\section{Prologue and Epilogue}
Also we have a second problem that reusing FPR indexes causes.
Since there is an ending number of registers the compiler can use for saving values, and this number is also reduced by the amount of fixed registers, the compiler occasionally stores values in memory before calling a function that needs some of the available registers by calling a so called ``prologue'' \citep{GCCint:funcentry}.
The compiler then restores the registers after the function has finished through an ``epilogue''.
To understand the principles of these we will take a look at how the back-end saves registers.
Before the compiler saves the registers it must check which registers need to be saved.
It then sets a variable for each register type accordingly.
In |rs6000_emit_prologue| the compiler checks for these variables and starts saving the respective registers.
Since the compilers looks for register numbers instead of types, we need to alter the case for FPRs and add a target flag, which activates these lines of code:
\begin{lstlisting}
for (i = 0; info->first_s2pp_reg_save + i <= LAST_S2PP_REGNO; i++)
    if (save_reg_p (info->first_s2pp_reg_save + i)){

        int offset = frame_off + 16 * i;
        rtx savereg = gen_rtx_REG (V8HImode, i+info->first_s2pp_reg_save);
        rtx areg = gen_rtx_REG (Pmode, 0);
        emit_move_insn (areg, GEN_INT (offset));
        rtx mem = gen_frame_mem (V8HImode,gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));
        insn = emit_move_insn (mem, savereg);
        rs6000_frame_related (insn, frame_reg_rtx, sp_off-frame_off, areg,
                                GEN_INT(offset), NULL_RTX);
    }
\end{lstlisting}
The compiler first loops over every save vector register and checks if the register needs to be stored.
Then an offset is computed that takes the current frame offset and adds 16 bytes(this is the register size) for every register of this type.
|savereg| and |areg| are two kinds of register that will later serve as operands.
|savereg| is the vector register we want to save and |areg| will we the GPR operand needed to use vector memory instructions\reference{fxvstax and fxvlax}
Hence |areg| loads the offset just calculated through |emit_move_insn|.
|emit_move_insn| will then insert an insn to the IR that moves the second argument to the first.
Now we can create a complete memory operand |mem| that takes |offset| in |areg| and |frame_reg_rtx|, which is the register holding the frame pointer to wheres all registers are saved, and combines them to a single operand.
As both register and memory are specified the compiler can emit a move insn that stores |savereg| to |mem|.
Finally |rs6000_frame_related| handles the insn which was just created and performs additional customizations which are needed as the moves belong to a function call.
After the functions code has been compiled the back-end invokes |rs6000_emit_epilogue| which uses the same functions as the prologue but restores the registers from memory.
Of course this function can not work on its but needs other functions that set parameters and prepare statements as well.
These functions were also extended by adding conditional cases for s2pp that mostly agree with the respective AltiVec cases.
An |rtx|, which was a type often used in the previous listing, is short for RTL expression and can be used by |insn|s as an argument.
RTL expressions can also contain information on how the operand is to be constructed as this allows chaining of operations.

\section{Reload}
As hinted in chapter \ref{chapter:methods} |reload| is a now deprecated process in GCC that mainly performs register allocation.
Obviously we need to add special handling of vector registers to |reload| because the registers we just added to the back-end must be used somehow.
We thus get back to |S2PP_REGS| which were the normal vector register form earlier.
As |reload| is capable of moving the contents of registers, we must specify that s2pp's registers are not compatible with GPRs or any other registers and also that storing/loading registers takes two GPRs that hold the memory address.
Because registers are quite different in their specifications and reload could possibly ask for any combination of source/destination register we declare only registers moves between s2pp registers only or between s2pp registers and memory valid.
This also creates the need for checking the register class of an RTL expression and eventually correcting the register class.
Additionally as |reload| does not support the addressing mode which AltiVec and s2pp both use, we must rearrange indirect addresses the same way AltiVec does.
At last we also need to validate the mode which is used.
All of this is done in a set of  |rs6000_secondary_reload_| functions which need to be modified.

\section{Built-ins and Machine Instructions}
Basically the back-end is now almost compatible with s2pp vector instructions.
The only thing that is left is specifying the machine instructions which move registers or access memory.
We therefore add a machine description file |s2pp.md| to the back-end which will contain all available vector instructions.
On which is |*s2pp_mov<mode>|:
\begin{lstlisting}
(define_insn "*s2pp_mov<mode>"
  [(set (match_operand:FXVI 0 "nonimmediate_operand" "=Z,kv,kv,*Y,*r,*r,kv,kv")
   (match_operand:FXVI 1 "input_operand" "kv,Z,kv,r,Y,r,j,W"))]
  "VECTOR_MEM_S2PP_P (<MODE>mode)
   && (register_operand (operands[0], <MODE>mode) 
   || register_operand (operands[1], <MODE>mode))"
  { 
   switch (which_alternative)
    {
    case 0: return "fxvstax %1,%y0";
    case 1: return "fxvlax %0,%y1";
    case 2: return "fxvsel %0,%1,%1";
    case 3: return "#";
    case 4: return "#";
    case 5: return "#";
    case 6: return "fxvsel %0,0,0";
    case 7: return output_vec_const_move (operands);
    default: gcc_unreachable ();
    }
  } 
  [(set_attr "type" "vecstore,vecload,vecsimple,store,load,*,vecsimple,*")])
\end{lstlisting}

We explained the basics of insn definition earlier in section \ref{section:insn} thus we will only explain this shortly.
The name is proceeded by an asterisk that renders the name not accessible directly because this insn shall only be referred to by the RTL sequence that follows.
The sequence is fairly simple and states that operand |0| is set by operand |1|.
It only gets interesting when taking a look at the constraints which build pairs for each operand and are separated by commas.
The first pair for example (|=Z| and |kv|) tells the compiler that a memory which is accessed by an indirect operand will be set by the contents of a vector register (this is the first use of our new constraint.
Which machine instruction is used for each pair of constraints is stated in the output template which may also be in C form.
Each case is indexed according to the position in the list of constraints so we take a look at |case 0| where we see the matching machine instruction for storing a vector in memory |fxvstax|.
The second operand contains also a character besides its number which is an operand modifier \cite{GCCint:asm} that will cause the operand |0| to be split into two address operands.
Besides the vector load instruction |fxvlax| we also note the |fxvsel| instruction which is used to move one vector register to another(pair |kv| and |kv|) and |case 6| which moves the contents of vector register |0| (this register is all |0|s) and thereby nulls that register.
The constraint |j| is the respective constraint for a zero vector.

But still there exist instruction which are not specified in detail but only by ``|#|''.
A |#| is the equivalent to stating that there is no instruction which can perform the instruction which is described by the RTL above.
This causes the compiler to look for different RTL that has the same effect but also has a machine instruction.

This process is called ``insn splitting'' and can also be used for optimization.
A developer may also define which RTL statements are equivalent by using |define_split| which is documented in \cite{GCCint:definesplit}.
As there exist splits for cases 3 through 5 in AltiVec, we may not define splits ourself.

Splitting insns is quite common for the GCC back-end because splitting insns with unspecific constraints allows for easier generation of code, since the back-end will search for code that fits the operands of the instruction which is called in the source files.
Even |s2pp_mov| is mainly used by calling a general vector move insn in |vector.md| that has the same RTL code without any constraints and then is split.
We only need to add the s2pp vector mode macro to the condition of the insn which is specified through |define_expand "mov<mode>|.
Expanding an insn which is done for this code basically follows the principle of splitting and goes even further in not giving the option for a machine instruction at all but relies on matching RTL in some machine description of the back-end.
Detailed information can be acquired in \cite{GCCint:defineexpand}.

As this is done for register moves is general we will do the same for specific loads and stores, by adding mode checking in |vector.md| and adding a matching insn to |s2pp.md|.

Beside adding the other insns we also need to add the function |rs6000_address_for_s2pp| which converts a standard address to an s2pp compatible form.
This code could be taken from an AltiVec equivalent since both vector units share the same form of memory referencing.

Now before we continue to other insns, we shall go back to |s2pp_mov| and take a look at |case 7| which applies for constant vectors.
Constant vectors which have a constant value that does not depend on a register thus is known at compile time.
GCC will look for such vectors and check if these vectors can be splatted (this means all vector elements have the same value).
This is a relict of AltiVec which offers a special splat instruction that takes a constant immediate value as operand.
We kept the function since we can achieve a similar effect for constant zero vectors by moving the zero register.
To distinguish between cases where this applies, we use the function |output_vec_const_move()| which is also used by AltiVec and implemented similar code to the existing AltiVec code but reduced this to the null vector case and emit a |#| for splitting otherwise.

Since we are now missing an instruction to use this split we will create a split ourselves which converts the immediate splat into a normal splat:
\begin{lstlisting}
(define_split
  [(set (match_operand:FXVI 0 "s2pp_register_operand" "")
   (match_operand:FXVI 1 "easy_vector_constant" ""))]
  "TARGET_S2PP && can_create_pseudo_p()"
  [(set (match_dup 2) (match_dup 3))
   (set (match_dup 0) (unspec:FXVI [(match_dup 2)] UNSPEC_FXVSPLAT))]
  "{
   operands[2] = gen_reg_rtx (SImode);
   operands[3] = CONST_VECTOR_ELT(operands[1], 1);
   }")
\end{lstlisting}

We split the upper RTL sequence which moves a constant vector to a vector register onto the bottom sequence which inserts an intermediate step.
|match_dup n| means that the operand should match the operand with the same index.
The C code that follows specifies the newly added operands 2 and 3 further and converts operand |1| into a single integer element because all values are the same.
The second RTL sequence uses the newly created integer and moves it to a GPR which then is splatted into a vector register.
An |unspec| operator together with |UNSPEC_...| tells the compiler that the operation is not specified but has a name to distinguish is from other unspecified operations.

\begin{lstlisting}
(define_insn "*s2pp_fxvsplat<FXVI_char>"
  [(set (match_operand:FXVI 0 "register_operand" "=kv")
   (unspec:FXVI
         [(match_operand:SI 1 "register_operand" "r")] UNSPEC_FXVSPLAT))]
  "TARGET_S2PP"
  "fxvsplat<FXVI_char> %0,%1"
  [(set_attr "type" "vecperm")])
\end{lstlisting}
is the insn the split refers to.

After we finally added memory instructions we can also implement them in |rs6000.c|.
In |rs6000_init_hard_regno_mode_ok| we assign the code for store and load instructions to the two supported modes in case the target flag is set but do not specify any others.

All that is left now are intrinsic functions that make use of the memory instructions.
Although by now the compiler would already support |asm| usage as shown in \ref{section:asm} and which we will get back to later on.
Still we do not want to stop there and also add intrinsic functions to the back-end.
This is done through several steps that were also described in an internship report \cite{heimbrecht_2017internship}.
Therefore we will only describe this briefly and refer to the report at times.

First we start defining insns for each vector instruction that is listed in \cite{nuxmanual}.
In order to allow access to the synram we implement insns that work similar to |fxvstax| and |fxvlax| and are called |fxvoutx| and |fxvinx|.
All of these insns exist with different conditionals and are named accordingly because load and store insns are hard to implement with an additional argument that is the conditional.
Simple arithmetic instructions exist in multiple versions that either support conditional execution or do not.
This is due to a problem that was discovered only recently with the PPU.
As tests revealed the conditional execution of arithmetic instructions works improperly and in case a condition does not apply the result of a previous instruction is written to the first operand.
Normally the operation should leave the contents of the operand untouched instead.
For this reason we implement a workaround through insn splits that utilizes |fxvselect| and its conditional execution as this does work as intended.
Though we still offer arithmetic operations without splits as this saves a clock cycle in comparison to having an additional |fxvselect| instruction.
Besides those simple arithmetic operations, |fxvadd...|, |fxvsub...| and |fxvmul...|, there also exist more complex operations that make use of the accumulator.
As of now these instructions should not be used with conditionals as further testing is imminent and it is not clear whether those conditionals would work.
Besides that does an extra instruction render the advantages of an accumulator meaningless.
Nonetheless do we implement those accumulator instructions together with a conditional argument which would allow for easier testing later on.
Also does the additional operand not influence the performance of the instruction in a bad manner since for the conditional |0| the instruction works the same as if the conditional was true for all elements.

We will refer back to this when discussing the results of extending the back-end.

Since this completes the insns we can go on and create built-ins in |rs6000-builtins.def| from these insns.
First though we must add macros that makes adding intrinsics easier.
The exact definition of those macros is described for AltiVec built-ins in \cite{heimbrecht_2017internship} but we can easily transfer those for s2pp by adding the |RS6000_BTM_S2PP| built-in mask which is identical with the target mask.
We then use the s2pp built-in macros to create built-in definitions for each insn and also each mode (halfword or byte).
Most built-ins follow the scheme of a normal function that has a result and a certain number of arguments.
Btu there exists a number of insns that do not produce an output as they set the accumulator or the conditional register.
These instructions need special handling and thus are defined as special built-ins.

Besides defining built-ins we also define overloads.
These are used to differ intrinsics through the types of their arguments later on what makes using them easier and stops false usage.
Overloads are also further explained in \cite{heimbrecht_2017internship}
As we are adding overloads we can put them to use in |rs6000-c.c| where overloads and built-ins are connected.
This is done through structures that combine the built-in and overload names with a return type and up to three arguments.

To actually make use of these structures, we will add a function to |rs6000-c.c| that resolves the overloaded built-ins and is again built upon an AltiVec function that does the very same.
Therefore we must tell the back-end which functions to use by making a target dependent decision in |rs6000.h| which overload-resolving function is handling overloads in general.
Also we need a functions in |rs6000.c| that handle built-ins in general.
First we create a new function |s2pp_expand_builtin| which is invoked by |rs6000_expand_builtin|.
This function handles all special built-ins that belong to s2pp and picks expander functions according to their name.
We therefore must create those expander functions that take care of certain kinds of built-ins.
One such group are memory intrinsics that handle explicit memory addressing and also apply to synram intrinsics.
These expanders are needed because of the special way that memory is accessed through indirect register referencing.
As for the operand modifiers we can use the same implementation that AltiVec uses but create a new function in case improvements may become necessary at some point in time.

Besides these expander functions we additionally create a new kind of expander function that did not exist before s2pp.
As there is a great number of instructions that do not return any values because they write the accumulator or the conditional registers, we create expander functions for various numbers of arguments that each do not handle a return operand.
These functions which were called |s2pp_expand_unaryx_bultin|, |s2pp_expand_binaryx_bultin| and |s2pp_expand_ternaryx_bultin| otherwise behave quite similar.

Now that we are already handling special built-ins we need to define those built-ins in |rs6000.c| as well.
|s2pp_init_bultins| takes care of that as it is a series of |define_builtin| functions which must be written explicitly in contrast to normal built-in functions, where this is done automatically.

We did not mention so far the special case of three other built-in function that belong to the group of special built-ins as well but differ in how the RTL code/machine instructions are generated.
|vec_ext|, |vec_init| and |vec_promote| describe functions which do not belong to a specific vector instruction but are compiler-constructed sequences of machine instructions that correspond to a certain action on a vector which is mainly performed in memory.
These functions are inspired by AltiVec's implementation which easily was transferable to s2pp.

Finally we conclude on built-ins by defining alternative names for built-in functions in |s2pp.h|.

A complete list of all intrinsic functions that the compiler supports at the time this thesis was written is available in the appendix \ref{appendix:builtinlist}.

\add{
    ?
target pragmas compiler anweisung
stack boundary -> put this together
frame offsetr
stackoffset
fix pck instructions 
}
