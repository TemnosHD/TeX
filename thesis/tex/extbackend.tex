\chapter{Extending the GCC Back-End}
\label{chapter:extbackend}
Since we now are familiar with the basics of processors, the PPU, compilers and GCC we can put this knowledge to use and start extending the GCC back-end.
There es a set of files we will systematically edit and keep referencing to as they are important parts of the rs6000 back-end and were changed in the process of extending the back-end. 
\begin{description}
    \item[rs6000.md] this is the machine description of the back-end in general and contains the insn definitions for all scalar functions
    \item[rs6000.h] is a header file which contains all macros and declaration of registers
    \item[rs6000.c] is the source file which implements all functions that are needed for generation of the back-end and other accompanying functions
    \item[rs6000.opt] lists the options and flags which can be set for the target
    \item[rs6000-builtins.def] contains the definitions of built-ins/intrinsics
    \item[rs6000-cpus.def] lists subtargets that belong to the rs6000 family
    \item[rs6000-c.c] links built-ins to overloaded built-ins
    \item[rs6000-opts.h] contains a set of enumerations that represent option values for the back-end
    \item[rs6000-protos.h] makes functions in |rs6000.c| globally available
    \item[rs6000-tables.opt] lists string/int equivalent to an enumeration which lists CPU types
    \item[driver-rs6000.c] mostly a collection of driver details for different targets
    \item[ppc-asm.h] sets macros for the use of |asm|
    \item[s2pp.md] is a new file that is the machine description of the nux' VE and contains insn definitions for the VE
    \item[s2pp.h] is the header file that defines aliases for built-ins
    \item[constraints.md] contains definitions of the constraints that are used
    \item[predicates.md] contains definitions of the predicates that are used
    \item[vector.md] declares insn definitions that apply to vector types in general
    \item[sysv4.h] initializes a variety of option flags an sets default values
    \item[t-fprules] sets soft-float as default for certain targets
\end{description}

Before we start it should be emphasized where inspiration was taken from in order to take the right steps when extending the back-end.
There exists no specific documentation on the rs6000 back-end whatsoever and most information on the ways it works is available through comments in code only.
There is however an existing vector extension which is included in the back-end and is quite similar to the vector extension we want to add.
The existing vector extension is the AltiVec Vector extension, we described earlier in this thesis.
The source code thus often shows strong similarities between AltiVec and s2pp functions.
Still handling AltiVec and s2pp vectors is separated throughout the back-end since mixing these and reusing function can both get messy and dangerous since at times one vector extension must be distinguished from another.
Also there do exist enough differences between these two VEs that combining functions and having separate ones would not make a big difference in the end.

We will start with adding the |nux| processor to the list of targets and also want to include mandatory flags with this.
Ideally the user only has to add the option flag |-mcpu=nux| when compiling in order to produce machine code for the nux.
the flags which have to be set when using the nux are:
\begin{description}
        \lstitem{-msdata=none} disables the use of a "small data section" which is like a data section but has a register constantly referring to it and thus has faster access than the normal data section. Globals, statics and small variables that are often used are preferably stored there.
        \lstitem{-mstrict-align} aligns all variable in memory which means that a variable always starts at a memory address without offset. Every variable requests at least 1 byte of memory when strictly aligned
        \lstitem{-msoft-float} tells the compiler that there is no FPU and all floating point operations have to simulated by software.
        \lstitem{-mno-relocatable} states that the program code has a fixed memory address that may not be altered.
\end{description}

To do so we first create the flag |-ms2pp| along with an option mask.
This should activate the vector extension and everything associated with it.
In rs6000.opt and we simply need to add the lines:
\begin{lstlisting}
ms2pp
Target Report Mask(S2PP) Var(rs6000_isa_flags)
Use s2pp instructions
\end{lstlisting}
|ms2pp| is the name of the target flag and the next lines defines which macros shall be defined.
|Target| means that the option is target specific, |Report| means that the option is to be printed when |-fverbose-asm| is activated.
|Mask(S2PP)| initializes a bitmask that is available through |OPTION_MASK_S2PP| which is attached to |rs6000_isa_flags| specified by |Var| and in parallel specifies a macro |TARGET_S2PP| that is set to |1|. \cite{GCCint:options}
When we are finished with this we need to specify |#define MASK_S2PP OPTION_MASK_S2PP| which is done in |rs6000.h| as |MASK_| is the standard.

Now we add the processor type which uses this flag as a standard.
There exist several lists that contain available targets and we need to add the nux to these.
First we add the |asm| flag that tells the assembler which system architecture is used.
As the nux is based on Power7 and the VE does not influence |asm| for the GPP we want nux to behave like Power7.
To do so we add |%{mcpu=nux: %(asm_cpu_power7)}| to |ASM_CPU_SPEC| and simultaneously add |{ "nux",  "%(asm_cpu_power7)" }| to |static const struct asm_name asm_names[]| as these arrays must be kept identical.
This will induce the assembler flag to be set to |-mpower7|.

Now we want to achieve something similar for the preceding phases of the back-end as as the description of flags above is mandatory to running nux.
First we will create an entry in |rs6000-cpus.def| which sets the flags accordingly:
\begin{lstlisting}
RS6000_CPU ("nux", PROCESSOR_POWER7, MASK_SOFT_FLOAT | MASK_S2PP | MASK_STRICT_ALIGN | !MASK_RELOCATABLE)
\end{lstlisting}
will define the processor as a Power7 type and add the masks for soft-float, strict-align and no-relocatable(negative of relocatable) as well as the new s2pp mask.
Setting a mask is the low-level equivalent to adding a flag as every flag induces a mask, which we saw earlier, and thus this will fit our cause.
Calling |RS6000_CPU| will basically generate an entry to the enumeration |rs6000_cpu_opt_value| which must be linked to a string following |-mcpu=|.
This is done in |rs6000-tables.opt| where a string, in our case |nux|, is associated with the |n|-1-th call of |RS6000_CPU| through:
\begin{lstlisting}
EnumValue
Enum(rs6000_cpu_opt_value) String(nux) Value(n)
\end{lstlisting}
One must basically count the calls of |RS6000_CPU| to get n.

As we are still missing the |-msdata=none| flag, we will take care of this now.
Because |-msdata| is not an ordinary target flag, we need to initialize it differently.
Depending on the string following |-msdata=| the back-end decides which mask is referred to when calling |rs6000_sdata|.
This is decided in |sysv4.h| through comparing with different valid strings.
Since we were only able to set option masks before we need a little work-around here that helps us setting the value of |rs6000_sdata|.
If |-msdata| was not defined as it is the case with |-mcpu=nux| the compiler will check through |else if|s what to do for |rs6000_sdata|.
We simply add one such check in front of all other |else if|s and check for all the target flags that |-mcpu=nux| sets.
Hence the target options will also set |rs6000_sdata| as we wish which is to |SDATA_NONE|.
Although there exists a case for which this condition applies even if |nux| is not set as target and that is when all target flags are set by hand.
Still if one chooses an explicit value for |-msdata| the option does not apply and the explicit value is taken into account.
This is somewhat not the ideal way of solving this problem but fulfills its purpose with as few side effects as possible.

Already this would allow us to use |-mcpu=nux| as target flag and |-ms2pp| as option flag.
But since the flags we used are mandatory to the s2pp extension we also want to check these flags before starting compilation.
First though we must create macros for each flag which the back-end notices.
This is done in |rs6000-c.c| in function |rs6000_target_modify_macros| where we can define macros depending on target flags.
\begin{lstlisting}
  if ((flags & OPTION_MASK_S2PP) != 0)
    rs6000_define_or_undefine_macro (define_p, "__S2PP__");
\end{lstlisting}

If |flags| and the respective option mask are set, |rs6000_define_or_undefine_macro| will define a macro which is the second argument if a macro is defined or undefined depends on the boolean |define_p| but the back-end takes care of this on its own.
We do this for all flags we are interested in.
Now we will use these new macros to check if the flags are set.
Before we do this though we create a new file that is |s2pp,h| and index this in |gcc/config.gcc| under |extra_headers| at |powerpc*-*-*|.
We do this so GCC actually invokes the header file as it is not referenced elsewhere.
After we added the usual conditional header macro to the file we add the first lines of code which are:
\begin{lstlisting}
#if !defined(__S2PP__)
#error Use the "-ms2pp" flag to enable s2pp support
#endif
\end{lstlisting}\unsure{do more often like this: one example for repetitive use}
Hence if |__S2PP__| was not defined because the target flag was not set, the compiler will emit an error that tells the user to set the target flag.
This is done for all macros that we set above so to prohibit false use of nux.
But we will also put in a second measure to prevent false use of |floats| by adding |nux| to the list of soft-float CPUs in |t-fprules|.

Since the preliminary requirements for the activation of the VE are now met, we start adding the remaining fundamental macros and also add a |vector| attribute that the user may use later.
First we add a new Vector type which we will need from time to time.
We call it |VECTOR_S2PP| and add it to the enumeration |rs6000_vector| in |rs6000-opts.h|.
To put this to use we will create macros in |rs6000.h| which test vector modes if they correspond to the available modes in s2pp.
Hence we add many macros of this form which take and argument and compare it to a valid s2pp type/value.
\begin{lstlisting}
#define VECTOR_UNIT_S2PP_P(MODE)            \
    (rs6000_vector_unit[(MODE)] == VECTOR_S2PP)
\end{lstlisting}
checks the mode's associated vector unit and compares this to |VECTOR_S2PP|.
We also add checking for specific vector modes which shall be chosen carefully.
The hardware only supports two types of vectors which are vectors with byte elements and vectors with halfword elements.
Thus the respective modes are |V16QImode| and |V8HImode| which can be checked by |S2PP_VECTOR_MODE(MODE)|.

Now that we added the s2pp vector we identify it with the available modes which is done in |rs6000.c|.
In |rs6000_init_hard_regno_mode_ok| we check for the s2pp target flag and assign |VECTOR_S2PP| to the modes |V16QImode| and |V8HImode|.
Also we add the modes for preferred modes when vectorizing a value in |rs6000_preferred_simd_mode| and decline the usage of offset addressing for these modes in |reg_offset_addressing_ok_p|.

We will now define an attribute to use these vector modes.
Thankfully GCC already supports a vector attribute which is also used by AltiVec.
Thus we can add s2pp to the |rs6000_attribute_table| and |rs6000_opt_mask[]| array with the same values as for AltiVec but changing the keyword.
This forces us to add the function |rs6000_handle_s2pp_attribute| which is the same as the AltiVec version but stripped off some vector modes which are not supported.
We could use those attributes already but they would come in quite unhandy thus we will define an alias to represent the new attribute in |rs6000-c.c|:
\begin{lstlisting}
builtin_define ("__vector=__attribute__((s2pp(vector__)))");
\end{lstlisting}
This is the same for AltiVec and copies the usage of vectors in AltiVec.
As does our addition of an s2pp case in |rs6000_attribute_takes_identifier_p| to complete the attribute.








As we are already in |rs6000.h| we also add the definition of an s2pp |word| which is 16 bits wide and declared in |UNITS_PER_S2PP_WORD|
\begin{lstlisting}
#define UNITS_PER_S2PP_WORD 16
\end{lstlisting} 
This is used in |rs6000.c| only when it is used to calculate the maximum amount of registers needed to hold a value of a certain mode. \cite{GCCint:regclasses} 



\section{Registers}
\label{section:register}
Now we start adding the registers of s2pp to the back-end.
There are three types of registers we need to add:
\begin{description}
    \item[32 vector registers] these are normal registers that hold vector values
    \item[1 accumulator] which is used for chaining arithmetic instructions and cannot be accessed directly
    \item[1 conditional register] which holds conditional bits and also cannot be accessed directly
\end{description}
Registers are declared in |rs6000.md| thus we will do so as well.
\begin{lstlisting}
...
(S2PP_COND_REGNO     32)
(FIRST_S2PP_REGNO    33)
(LAST_S2PP_REGNO     63)
(S2PP_ACC_REGNO      64)
...
\end{lstlisting}\todo{necessary?}
is added to the Definition of constants at the beginning of |rs6000.md|, where we give a range for the vector registers and after which we pick specific register numbers for the special vector registers.
The number of these special vector registers does not matter though as we only need a number which no other registers that is used by nux refers to.
There is a reason why we put the conditional register at 32 and only provide 31 vector registers:
As the GPRs need the first 32 registers numbers (0-31) and there is never an FPU in nux, we want to use the 32 registers normally reserved to FPRs.
However during the first tests of nux with its vector extension it became apparent that a reserved register with all bits set to |0| would come in handy at times.
For one reason nux' instruction set does not include logical instructions especially no exclusive or (|xor|) function which is the standard way of having a registers set to all |0|s (since |xor|ing a value/register with the same value/register will always return |0|) and also it does not provide an |or| function which is the standard way of moving registers around as it was shown in section \ref{section:asm}\todo{check this refernce}.
This led to the problem of ``nulling'' a register at times it was needed.
Therefore the first register was left out and filled with zeros in order to be able to simply move/copy this register to a different one that needed to be nulled.
Moving around registers was also realized differently than for normal architectures as |fxvselect| was used instead of |or| where the first operand is the destination while second and third operand are the source.
The last operand, which is the conditional one, is set to |0| or left out as this substitutes the contents of the first operand always with that of the second operand.
Now as this renders a simple work-around, substituting |xor| is more difficult and although there are ways of utilizing |fxvselect| to copy its functionality \todo{explain this later} which we will care about later on.
Particularly as |fxvselect| is the fast vector instruction as it takes only one cycle to complete and all other arithmetic instruction most likely take significantly more cycles.
For this reason nulling a register by subtracting it by itself and storing the result in the same register would take more time hence would cost performance.
Therefore the trade-off of having one less register at hand instead of wasting clock cycles continuously is adequate.
Therefore since we do not want to reference the first vector register and cannot access the condition register by reference we simply reuse the register number for this cause.
Unfortunately we do not have a second dispensable register of that kind and thus need to find a different index for the accumulator - though the same non-availability as for the conditional register applies.
Luckily the POWER architecture does not reference the register index 64 for some reason so we can use that index without causing any conflict.

Now since we declared the vector registers' indexes we will create fitting macros as well.
We need to decide on which registers shall serve which purpose.
In this regard we shall also emphasize a little on fixed, call-used and saved registers.
Fixed registers serve purpose that does not allow them to hold any other values at any time at all.
Call-used registers are registers that are also not available for general register allocation as they are used for function calls and returning values.
Only saved registers can be used for general register allocation as these may hold values over function calls such as variables that are often used throughout the program.
This is done through macros which decide on the first saved register (in our case the 20th vector register) and list registers available for function arguments (a set of |S2PP_ARG_| macros).
Also |FUNCTION_..._REGNO_P(N)| tells us if register |N| is used for function arguments in general.
This number of course can be optimized depending on the applications for the nux and also the style of programming but we keep the same number of registers saved as AltiVec and the FPU do.

Of course we need to go through the source files to find any use of those macros and add the new s2pp macros.
We will not mention this every time as this is a standard procedure.

Now we need to get even more specific on the way the registers are organized.
First we add |S2PP_REGS|, |S2PP_C_REG|, and |S2PP_ACC_REG| to the enumeration |reg_class| and define the identical names in |REG_CLASS_NAMES|.
Then we need to specify the contents of our new register classes in |REG_CLASS_CONTENTS|.
\begin{lstlisting}
/* S2PP_REGS.  */                                                 \
{ 0x00000000, 0xfffffffe, 0x00000000, 0x00000000, 0x00000000 },   \
/* S2PP_C_REG.  */                                                \
{ 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },   \
/* FLOAT_REGS.  */                                                \
{ 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000 },   \
/* S2PP_ACC_REG.  */                                              \
{ 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000 },   \
\end{lstlisting}
Each hexnumber in these arrays can be viewed as a bit mask where the least significant bit is the first register, next higher order bit the second register and so on.
Each number is 32-bit and therefore equivalent to 32 registers.
The following numbers start where the previous one ended, therefore is the second number the bit mask for registers 32 through 63 (32 is the 33rd register).
Therefore does |0xfffffffe| mask all register except for number 32 which is covered by |0x00000001| and 64 is masked the same way.
One can see that the FPRs are masked completely as |FLOAT_REGS|.
The reason for this order is that subsequent entries must not me subsets of previous masks but may extend these.
Since we also included a register which was not used at all before we also have to change subsequent masks accordingly.

Now that we defined register classes we again add macros to compare these as we did before.
\begin{lstlisting}
#define S2PP_REG_CLASS_P(CLASS)         \
    ((CLASS) == S2PP_REGS)
...
\end{lstlisting}

Next we need to pick names for those new registers that we just defined.
These were chosen according to the constraints we will define next which are |kv| for normal vector registers, |kc| for the conditional register, |ka| for the accumulator.
Defining (in this case alternative) names for registers is also part of a macro |ADDTIONAL_REGISTER_NAMES| with elements that look like:
\begin{lstlisting}
  {"kc", 32}, {"kv0",  33}, {"kv1",  34}, {"kv2",  35},   \
  ...
\end{lstlisting}
The strings are the names for the registers and the integers are their indexes.

Now we also want to add the constraints which we just proposed.
we therefore go to |constraints.md| and add the following code for |kv|, |kc| and |ka|:
\begin{lstlisting}
(define_register_constraint "kv" "rs6000_constraints[RS6000_CONSTRAINT_kv]"
    "s2pp vector register")
\end{lstlisting}
where the first string is the register constraint's name and |rs6000_constraints[RS6000_CONSTRAINT_kv]| will be assigned a register name later on in |rs6000.c|,where it is also declared, which in this case is |S2PP_REGS| though this is only done if the target flag |-ms2pp| was set.
The last string is only for documentary purposes.\cite{GCCint:constraints}
We chose |k| as the first initial of s2pp registers because there are very few letters left which are not used as a constraint already and k is one of them which is at least somewhat associated with the processor (``nuks'').
The second character was chosen from the initial of the respective register type.

The next step which is necessary to make the registers widely accessible is adding them to |rs6000.c|.
For once we add the new registers to |rs6000_debug_reg_global| in order for them to be listed when printing out debug information.
This is done the same way AltiVec registers are implemented and fairly easy.
The same applies for pretty much all debugging support (THIS IS NOT gdb) therefore we do not mention additions to debugging, but in general these were done.
It is far more important to add the registers to |rs6000_init_hard_regno_mode_ok| which initializes global tables that are based on register size.
Basically every index in |rs6000_regno_regclass[]| is given a register class which corresponds to the register of that index and afterwards each register class is assigned a register type in |reg_class_to_reg_type[]|.
\begin{lstlisting}
for (r = 32+1; r < 64; ++r)
    rs6000_regno_regclass[r] = S2PP_REGS;
...
rs6000_regno_regclass[S2PP_COND_REGNO] = S2PP_C_REG;
rs6000_regno_regclass[S2PP_ACC_REGNO] = S2PP_ACC_REG;

reg_class_to_reg_type[(int)S2PP_REGS] = S2PP_REG_TYPE;
...
}
\end{lstlisting}

This is done only when |TARGET_S2PP| is true and substitutes the |FLOAT_REGS| at indexes 33 through 63 with |S2PP_REGS| and also adds the conditional and accumulator registers.
To complete the process the register classes are assigned a respective register type which was added to the enumeration |rs6000_reg_type| before that.
It is important to note that the s2pp normal register type was also added to the list of standard register types (again as a macro), as s2pp registers are meant to act like normal registers and also to the floating point/vector register types which is necessary as they are handled differently later in the source file.

Register can also be fixed (\reference{previous section}) according to compiler flags which is done in |rs6000_conditional_register_usage|.
E.g. when the flag for soft-float is set, the compiler calls all FPRs fixed (ergo not available), which is contrary to our plan of using these registers.
That is the reason why we add the alternative condition that the s2pp flag may not be set for this to happen.
Instead we fix the registers 32 and 64 which are the used otherwise (|kc| and |ka|).

Now that we fulfilled all measures of adding the registers to |rs6000.c| we need to add them to the list of possible |asm| operands in 
|ppx-asm.c| where a simple definition like |#define k0 1| is enough if this is done for each register name.
This tells the compiler to substitute |k0| for 1 as only pure integers are valid machine operands.

The last step to completing register usage for the back-end is adding fitting predicates in |predicates.md|.
We can copy these from the respective AltiVec predicates and change both the vector specific macros and the predicates' names.
The affected predicates are:
\begin{description}
        \lstitem{s2pp_register_operand} is a vector that is stored in a s2pp register
        \lstitem{easy_vector_constant} returns 1 if the operand is a constant vector and now also tests for s2pp vectors and calls a new function |easy_s2pp_constant|
        \lstitem{indexed_or_indirect_operand} applies for indexed or indirect operands (e.g. memory addresses in registers) and now supports the case of a s2pp vector operand as for AltiVec vectors
        \lstitem{s2pp_indexed_or_indirect_operand} is the same but only for s2pp vectors, not AltiVec
\end{description}
If one wants to add own predicates, GCC offers a manuals entry \cite{GCCint:predicates}.

The |easy_s2pp_constant| function checks if an operand is ``splittable'' which means that all elements are the same and thus can be generated through a split instruction.
To check this the operand is analyzed sequentially if either of the two available splats can synthesize the same operand.
This was also transferable from an AltiVec equivalent with the exception that one vector mode had to be removed.
prologue epilogue
Additionally the similar function |gen_easy_s2pp_constant| could also be transfered as it works the same way but generates RTL code that will create a constant vector operand from a different operand.

Now as we have completely added the new registers, we must take care of some consequences this caused.
Mainly our problem is that we reused the floating point registers and did not mark them as fixed \reference{earlier}.
For this reason we must scan the source files for |FP_REGNO_P(N)| and add an exception with |&& !TARGET_S2PP| when it is necessary.
This is especially the case when dealing with hard registers and having the compiler emit register moves.

Also we have a second problem that reusing FPR indexes causes.
Since there is an ending number of registers the compiler can use for saving values, and this number is also reduced by the amount of fixed registers, the compiler occasionally stores values in memory before calling a function that needs some of the available registers by calling a so called ``prologue''.
The compiler then restores the registers after the function has finished through an ``epilogue''.
Both functions are essential to ...


negated target flags add s2pp negation
reload and stoer
legitimize address


copy helper direct move
FPR regno conflict

\add{
-builtins

-helper functions
}

\add{
BTM bultin mask
target pragmas compiler anweisung
stack boundary -> put this together
frame offsetr
stackoffset
reload
rtx
}
